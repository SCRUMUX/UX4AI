<!DOCTYPE html>
<html lang="ru" class="theme-dark">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" name="viewport"/>
<!-- iOS Safari: —Ç–µ–º–Ω–∞—è status bar -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="mobile-web-app-capable" content="yes"/>
<!-- Android Chrome: theme color -->
<!-- PHASE C2: Initial value uses token fallback, will be updated dynamically via JavaScript based on current theme -->
<!-- Theme color will be updated dynamically via JavaScript based on current theme -->
<!-- PHASE 3E: Meta theme-color will be updated dynamically via JavaScript from CSS variables -->
<meta name="theme-color" content="var(--color-dark-bg-primary)" id="meta-theme-color"/>
<meta name="msapplication-navbutton-color" content="var(--color-dark-bg-primary)" id="meta-navbutton-color"/>
<title>UX4AI: UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI</title>
<meta name="description" content="–ü—Ä–æ–µ–∫—Ç–∏—Ä—É—é UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI‚Äë—Å–µ—Ä–≤–∏—Å–æ–≤. –ü–∞—Ç—Ç–µ—Ä–Ω—ã, –ø–æ–¥—Ö–æ–¥—ã –∏ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ò–ò."/>
<meta name="keywords" content="UX, AI, UX –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã, –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ, –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –ò–ò, UX4AI"/>
<link rel="canonical" href="https://ux4ai.pro/"/>

<!-- Open Graph -->
<meta property="og:type" content="website"/>
<meta property="og:url" content="https://ux4ai.pro/"/>
<meta property="og:site_name" content="UX4AI"/>
<meta property="og:title" content="UX4AI: UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI"/>
<meta property="og:description" content="–ü—Ä–æ–µ–∫—Ç–∏—Ä—É—é UX‚Äë–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI‚Äë—Å–µ—Ä–≤–∏—Å–æ–≤. –ü–∞—Ç—Ç–µ—Ä–Ω—ã, –ø–æ–¥—Ö–æ–¥—ã –∏ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ò–ò."/>
<!-- Open Graph images (multiple formats) -->
<meta property="og:image" content="https://ux4ai.pro/preview.webp?v=3"/>
<meta property="og:image:type" content="image/webp"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="630"/>
<meta property="og:image" content="https://ux4ai.pro/preview.png?v=3"/>
<meta property="og:image:type" content="image/png"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="630"/>
<meta property="og:image" content="https://ux4ai.pro/preview.jpg?v=3"/>
<meta property="og:image:type" content="image/jpeg"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="630"/>

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="UX4AI: UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI"/>
<meta name="twitter:description" content="–ü—Ä–æ–µ–∫—Ç–∏—Ä—É—é UX‚Äë–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI‚Äë—Å–µ—Ä–≤–∏—Å–æ–≤. –ü–∞—Ç—Ç–µ—Ä–Ω—ã, –ø–æ–¥—Ö–æ–¥—ã –∏ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ò–ò."/>
<meta name="twitter:image" content="https://ux4ai.pro/preview.webp?v=3"/>
<meta name="twitter:image:alt" content="UX4AI: UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI"/>

<!-- Verification (replace content values with real codes) -->
<meta name="google-site-verification" content="REPLACE_WITH_GOOGLE_CODE"/>
<meta name="yandex-verification" content="REPLACE_WITH_YANDEX_CODE"/>

<!-- Schema.org Person and WebSite markup -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Person",
  "name": "–í–ª–∞–¥–∏–º–∏—Ä –ö–æ—Å—Ç—è–ª",
  "url": "https://ux4ai.pro/",
  "jobTitle": "UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä",
  "description": "–ü—Ä–æ–µ–∫—Ç–∏—Ä—É—é UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI-—Å–µ—Ä–≤–∏—Å–æ–≤. –ü–∞—Ç—Ç–µ—Ä–Ω—ã, –ø–æ–¥—Ö–æ–¥—ã –∏ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ò–ò.",
  "worksFor": {
    "@type": "Organization",
    "name": "UX4AI"
  },
  "knowsAbout": ["UX Design", "AI", "User Interface Design", "UX Architecture", "AI Products"],
  "sameAs": [
    "https://t.me/scrumux"
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "UX4AI ‚Äî UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI",
  "url": "https://ux4ai.pro/",
  "description": "–ü—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ UX-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤ –¥–ª—è AI-—Å–µ—Ä–≤–∏—Å–æ–≤. –ü–∞—Ç—Ç–µ—Ä–Ω—ã, –ø–æ–¥—Ö–æ–¥—ã –∏ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ò–ò.",
  "author": {
    "@type": "Person",
    "name": "–í–ª–∞–¥–∏–º–∏—Ä –ö–æ—Å—Ç—è–ª"
  },
  "inLanguage": "ru-RU"
}
</script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105120842', 'ym');

    ym(105120842, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105120842" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->


<!-- Favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="./favicon.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="./favicon.png"/>
<link rel="apple-touch-icon" sizes="180x180" href="./android-chrome-192x192.png"/>
<link rel="icon" type="image/png" sizes="192x192" href="./android-chrome-192x192.png"/>
<link rel="icon" type="image/png" sizes="512x512" href="./android-chrome-512x512.png"/>
<link rel="stylesheet" href="./styles/tokens.css?v=111"/>
<link rel="stylesheet" href="./styles/main.css?v=247"/>
<!-- CRITICAL: Force theme class before any JS runs to ensure CSS variables resolve correctly -->
<script>
  (function() {
    // Read saved theme or default to dark
    var savedTheme = 'dark';
    try { savedTheme = localStorage.getItem('colorTheme') || 'dark'; } catch(e) {}
    if (savedTheme !== 'light' && savedTheme !== 'dark') savedTheme = 'dark';
    // Apply theme classes immediately
    document.documentElement.classList.add('theme-' + savedTheme);
    console.log('[Theme Bootstrap] Applied theme class:', savedTheme);
  })();
</script>
<style>
    /* PHASE C3.4: Base styles moved to main.css */
    /* Mobile performance optimizations moved to main.css */
    /* PHASE C3.4: #three-container, #labels, .label styles moved to main.css */
    /* PHASE C3.4: .hud, .chip, .spacer, .hint styles moved to main.css */

    /* PHASE C3.4: #overlay and #hud-backdrop styles moved to main.css */
    /* Hide unused legacy panels by default */
    #object-icon, #big-panel, #small-panel {
      display: none;
    }
    /* Detached HUD elements - styles moved to main.css */
    /* #hud-object-icon styles in main.css */
    /* PHASE C3.4: #hud-small-panel navigation and buttons styles moved to main.css */

    /* PHASE C3.4: header, header-btn, theme-toggle-container styles moved to main.css */
    /* PHASE C3.4: #links-panel styles moved to main.css */
    /* Ensure HUD buttons look slightly bolder: we already set weight via main
       declaration. This override is removed to avoid conflicting with the
       unified button styles. */
    /* Removed redundant HUD weight override */

    /* PHASE C3.5: Global square corners moved to main.css */
    /* NOTE: All border-radius rules are now in main.css to avoid duplication */
    
    /* During tour, grid should be visible through the card */
    /* Grid is below card but visible through transparent card background */
    /* Grid canvas visibility when tour overlay is visible - handled in main.css */
    /* Removed inline style - tour effects limited to #tour-overlay */
    /* Default browser cursors in use */
    /* HUD mode styles moved to main.css - use specificity instead of !important */
  
/* HUD controls styles moved to main.css - use specificity instead of !important */
/* Media queries moved to main.css - use specificity instead of !important */


/* Navigation styles moved to main.css - use specificity instead of !important */
/* Links in big panel styles moved to main.css - use specificity instead of !important */

/* Mobile orbit mode toggle */
/* PHASE 3E: Styles moved to main.css to eliminate duplication */

/* Disable smooth scroll globally */
html {
  scroll-behavior: auto;
}

/* === Mobile: scroll the HUD container instead of the big panel to guarantee bottom visibility === */
/* PHASE: Styles moved to main.css */

/* Ultra-narrow safeguard styles moved to main.css */


/* HUD title and summary styles moved to main.css */


/* === Tablet: mirror mobile behavior (container scroll, tail always reachable) === */
/* PHASE: Styles moved to main.css */

/* Mobile navigation styles moved to main.css */

/* Scrollbar styles moved to main.css */

/* === HUD Grid hologram effect === */
/* PHASE AUDIT: Moved to main.css */

/* Container scrollbar styles moved to main.css */


/* remove stray flex override; container visibility controlled above */

/* === Header buttons default spacing via .header-spacer (override removed) === */

/* (Reset rules are defined once above; duplicates removed) */

  /* === HUD spacing normalization === */
  /* PHASE AUDIT: All HUD spacing rules moved to main.css */

  /* === Tour restart button (text "–ü—É—Å–∫") === */
  /* Styles inherited from .header-btn in main.css */

</style>
</head>
<body class="theme-dark">

<!-- Preloader overlay -->
<!-- Refactored: inline HTML, no iframe -->
<!-- Critical CSS in <head> ensures visibility even if main.css hasn't loaded yet -->
<div id="preloader-overlay" role="status" aria-live="polite" aria-label="Loading UX4AI">
  <div class="preloader-inner">
    <div class="preloader-logo">
      <svg class="ux4ai-logo" viewBox="0 0 1200 320" aria-hidden="true" id="logo">
        <defs>
          <linearGradient id="grad" x1="0" y1="0" x2="1" y2="0">
            <stop offset="0%" stop-color="#e6f1ff"/>
            <stop offset="100%" stop-color="#b6cfff"/>
          </linearGradient>

          <!-- –§–∏–ª—å—Ç—Ä —à—É–º–∞/–¥–∏—Å–ø–ª–µ–π—Å–º–µ–Ω—Ç–∞ –¥–ª—è glitch outline -->
          <filter id="noiseDisp" x="-20%" y="-40%" width="140%" height="180%">
            <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="3" result="noise"/>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G"/>
          </filter>
        </defs>

        <!-- base shadow and main -->
        <text x="600" y="160" class="ux4ai-glyph ux4ai-text shadow" id="shadow">UX4AI</text>
        <text x="600" y="160" class="ux4ai-glyph ux4ai-text main" id="main">UX4AI</text>

        <!-- OUTLINE-ONLY GLITCH layers (same size, only stroke) -->
        <g id="glitchGroup" filter="url(#noiseDisp)" opacity="0">
          <text x="600" y="160" class="ux4ai-glyph" id="gC"
                fill="none" stroke="var(--preloader-glitch-cyan)" stroke-width="2">UX4AI</text>
          <text x="600" y="160" class="ux4ai-glyph" id="gM"
                fill="none" stroke="var(--preloader-glitch-magenta)" stroke-width="1.6">UX4AI</text>
        </g>
      </svg>
    </div>

    <div class="preloader-caption">initializing interface</div>

    <div class="preloader-stream-wrap">
      <ul class="preloader-stream" id="streamList"></ul>
    </div>
  </div>
</div>

<script>
  // Simple preloader visibility script - runs immediately after element is parsed
  (function() {
    try {
      const overlay = document.getElementById('preloader-overlay');
      if (overlay) {
        // Critical styles are already set in <head> critical CSS
        // Only ensure visibility if somehow critical CSS didn't apply
        overlay.classList.remove('hidden');
        overlay.classList.remove('hidden');
        if (typeof performance !== 'undefined' && performance.now) {
          window.__PRELOADER_START_TIME__ = performance.now();
        }
      }
    } catch (e) {
      console.error('[Bootstrap] Error showing preloader:', e);
    }
  })();
</script>

<!-- Guided Tour Overlay (A/B/C) -->
<div id="tour-overlay" aria-hidden="true" class="hidden" inert>
  <div class="tour-backdrop"></div>
  <div class="tour-card" role="dialog" aria-modal="true" aria-labelledby="tour-title" aria-describedby="tour-text">
    <div class="tour-header">
      <h2 id="tour-title"></h2>
      <p class="tour-sub" id="tour-sub"></p>
    </div>
    <div class="tour-body">
      <p id="tour-text"></p>
    </div>
    <div class="tour-interactives" id="tour-interactives" aria-hidden="true">
      <noscript>
        <div class="tour-interactives-fallback">
          <p style="color: var(--hud-text-muted); font: 400 14px/1.3 ui-sans-serif, system-ui; text-align: center; margin: 0;">
            –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Ç—Ä–µ–±—É—é—Ç JavaScript
          </p>
        </div>
      </noscript>
    </div>
    <div class="tour-actions" id="tour-actions"></div>
    <div class="tour-frame-lines" aria-hidden="true"></div>
  </div>
  <!-- PHASE C4: Tour styles moved to main.css -->
</div>

<!-- No-JS Fallback -->
<noscript>
  <div style="position: fixed; inset: 0; z-index: 9999; background: var(--color-dark-bg-primary); color: var(--color-light-text-primary); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; text-align: center; font-family: ui-sans-serif, system-ui, sans-serif;">
    <h1 style="font-size: 24px; font-weight: 600; margin: 0 0 16px 0; color: var(--color-light-text-secondary);">–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Ç—Ä–µ–±—É—é—Ç JavaScript</h1>
    <p style="font-size: 16px; line-height: 1.5; max-width: 600px; margin: 0 0 24px 0; color: var(--color-light-text-muted);">
      –≠—Ç–æ—Ç —Å–∞–π—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 3D-–∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤—ã –∏ —Ç—Ä–µ–±—É–µ—Ç –≤–∫–ª—é—á–µ–Ω–∏—è JavaScript –¥–ª—è –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã.
    </p>
    <p style="font-size: 16px; line-height: 1.5; max-width: 600px; margin: 0 0 24px 0;">
      –í—ã –º–æ–∂–µ—Ç–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º–∏ –≤ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ:
    </p>
    <a href="./Vladimir_Kostyal_Resume.pdf" target="_blank" style="display: inline-block; padding: 12px 24px; background: var(--color-accent-primary); color: var(--color-light-text-on-brand); text-decoration: none; font-weight: 500; margin-bottom: 12px;">
      –°–∫–∞—á–∞—Ç—å —Ä–µ–∑—é–º–µ (PDF)
    </a>
    <p style="font-size: 14px; color: var(--color-light-text-muted); margin-top: 24px;">
      –ò–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å –Ω–∞–ø—Ä—è–º—É—é: <a href="https://t.me/scrumux" target="_blank" style="color: var(--color-accent-primary); text-decoration: underline;">Telegram</a>
    </p>
  </div>
</noscript>

<!-- Header -->
<header id="site-header">
  <div class="header-logo">
    <img src="./UX4AILOGO.svg" alt="" class="header-icon" width="24" height="24">
    <span class="name">UX4AI</span>
    <span class="tagline"> UX –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è AI —Å–µ—Ä–≤–∏—Å–æ–≤</span>
  </div>
  <div class="header-spacer"></div>
  <button class="header-btn" id="btn-demo">–î–µ–º–æ</button>
  <button class="header-btn" id="btn-links">–°—Å—ã–ª–∫–∏</button>
  <button class="header-btn" id="btn-about">–ê–≤—Ç–æ—Ä</button>
  <!-- –ö–Ω–æ–ø–∫–∏ –ü—É—Å–∫ –∏ –¢–µ–º–∞ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ JS –Ω–∞–ø—Ä—è–º—É—é –≤ header -->
</header>

<!-- Mode banner -->
<div id="mode-banner">–†–µ–∂–∏–º: –û—Ä–±–∏—Ç–∞ (ESC ‚Äî –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—é)</div>

<!-- Mobile orbit mode toggle -->
<div id="mobile-orbit-toggle">
  <button id="toggle-orbit-btn">
    <img id="toggle-orbit-icon" src="./camera_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="Camera" loading="lazy" width="24" height="24" />
  </button>
</div>

<!-- Links panel -->
<div id="links-panel">
  <button class="close-btn" id="btn-links-close">‚úï</button>
  <div class="link-row"><a href="#" id="lnk-tg-chat" target="_blank">üí¨ –ù–∞–ø–∏—Å–∞—Ç—å –≤ Telegram</a></div>
  <div class="link-row"><a href="#" id="lnk-tg-community" target="_blank">üë• –ü–µ—Ä–µ–π—Ç–∏ –≤ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ</a></div>
  <div class="link-row"><a href="#" id="lnk-resume" target="_blank">üìÑ –†–µ–∑—é–º–µ (PDF)</a></div>
  <div class="link-kicker">–í—Å–µ –∫–æ–Ω—Ç–∞–∫—Ç—ã –æ—Ç–∫—Ä—ã–≤–∞—é—Ç—Å—è –≤ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ.</div>
</div>

<!-- Canvas and labels -->
<div id="three-container"></div>
<div id="labels"></div>

<!-- HUD elements -->
<div id="overlay"></div>
<!-- HUD backdrop (similar to tour backdrop) -->
<div id="hud-backdrop" class="hidden"></div>

<div id="hud-object-icon"></div>
<!-- Wrap the HUD panels inside a container so they can be centred and stacked responsively -->
<div id="hud-container">
  <div id="hud-small-panel">
    <button data-index="0">–í–∞—Ä–∏–∞–Ω—Ç 1</button>
    <button data-index="1">–í–∞—Ä–∏–∞–Ω—Ç 2</button>
    <button data-index="2">–í–∞—Ä–∏–∞–Ω—Ç 3</button>
          </div>
  <div id="hud-big-panel"></div>
        </div>

  <!-- Grid overlay (thin through-borders that form the HUD grid) -->
  <div id="grid-overlay" aria-hidden="true"></div>
  <!-- Background grid under HUD overlay -->
  <canvas id="grid-canvas-bg" aria-hidden="true"></canvas>
  <canvas id="grid-canvas" aria-hidden="true"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/"
  }
}
</script>
<script>
  // ===== PHASE B.1: Compute base path for UX4AI (simplified) =====
  // –°—á–∏—Ç–∞–µ–º, —á—Ç–æ index.html –ª–µ–∂–∏—Ç –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞ UX4AI,
  // –≤—Å–µ –º–æ–¥—É–ª–∏ –∏ —Ñ–∞–π–ª—ã –ø–æ–¥–∫–ª—é—á–∞—é—Ç—Å—è –û–¢–ù–û–°–ò–¢–ï–õ–¨–ù–´–ú–ò –ø—É—Ç—è–º–∏ –æ—Ç –Ω–µ–≥–æ.
  const base = '.';
  window.__UX4AI_BASE_PATH__ = base;
  console.log('[Bootstrap] UX4AI base path set to "." (relative root)');
  
  // ===== Preloader initialization (refactored: no longer uses iframe) =====
  // Preloader is now inline HTML, initialized via core/preloader.js module
  // NOTE: Preloader visibility script is located immediately after #preloader-overlay element
</script>
<script type="module">
// ===== Preloader is already shown by synchronous script above =====
// This module script only initializes animation, doesn't need to show preloader
console.log('[Bootstrap] Module script started, DOM ready state:', document.readyState);

// ===== DIAGNOSTIC FUNCTION: dumpLayoutSnapshot =====
// Temporary diagnostic function to compare layout state at different initialization stages
function dumpLayoutSnapshot(label) {
  const html = document.documentElement;
  const body = document.body;
  
  // Get classes
  const htmlClasses = html.className || '';
  const bodyClasses = body.className || '';
  
  // Check for preload lock
  const hasPreloadLock = htmlClasses.includes('ux4ai-preload-lock') || bodyClasses.includes('ux4ai-preload-lock');
  
  // Check header buttons
  const themeToggleBtn = document.getElementById('theme-toggle-btn');
  const headerBtns = document.querySelectorAll('.header-btn');
  
  const headerButtonsState = {
    themeToggleBtn: {
      exists: !!themeToggleBtn,
      display: themeToggleBtn ? getComputedStyle(themeToggleBtn).display : 'N/A',
      visibility: themeToggleBtn ? getComputedStyle(themeToggleBtn).visibility : 'N/A',
      parent: themeToggleBtn ? (themeToggleBtn.parentNode?.id || 'unknown') : 'N/A'
    },
    allHeaderBtns: {
      count: headerBtns.length,
      buttons: Array.from(headerBtns).map(btn => ({
        id: btn.id || 'no-id',
        className: btn.className || '',
        display: getComputedStyle(btn).display,
        visibility: getComputedStyle(btn).visibility
      }))
    }
  };
  
  // Check HUD panels
  const hudBigPanel = document.getElementById('hud-big-panel');
  const hudSmallPanel = document.getElementById('hud-small-panel');
  const hudContainer = document.getElementById('hud-container');
  
  const hudState = {
    bigPanel: {
      exists: !!hudBigPanel,
      display: hudBigPanel ? getComputedStyle(hudBigPanel).display : 'N/A'
    },
    smallPanel: {
      exists: !!hudSmallPanel,
      display: hudSmallPanel ? getComputedStyle(hudSmallPanel).display : 'N/A'
    },
    container: {
      exists: !!hudContainer,
      display: hudContainer ? getComputedStyle(hudContainer).display : 'N/A'
    }
  };
  
  const snapshot = {
    label,
    timestamp: new Date().toISOString(),
    htmlClasses,
    bodyClasses,
    hasPreloadLock,
    headerButtons: headerButtonsState,
    hud: hudState
  };
  
  console.log(`[LayoutSnapshot:${label}]`, snapshot);
  return snapshot;
}

// Expose diagnostic function globally for use in other modules
if (typeof window !== 'undefined') {
  window.dumpLayoutSnapshot = dumpLayoutSnapshot;
}

async function init() {
  try {
    // ===== Initialize preloader animation in background (don't block) =====
    // Preloader is already visible thanks to synchronous script above
    const base = window.__UX4AI_BASE_PATH__ || '';
    let hidePreloaderFn = null;
    let loadFallbackTimeout = null; // For window.load fallback
    
    // Load preloader module in background (don't await - non-blocking)
    const preloaderInitPromise = (async () => {
      try {
        // Wait for DOM if needed
        if (document.readyState === 'loading') {
          await new Promise(resolve => {
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', resolve, { once: true });
            } else {
              resolve();
            }
          });
        }
        
        // Import preloader module
        const preloaderModule = await import(`${base}/core/preloader.js`);
        const initPreloader = preloaderModule.initPreloader;
        hidePreloaderFn = preloaderModule.hidePreloader;
        
        if (!initPreloader || !hidePreloaderFn) {
          throw new Error('Preloader module exports not found');
        }
        
        // Initialize animation
        const overlayEl = document.getElementById('preloader-overlay');
        if (overlayEl) {
          initPreloader();
          console.log('[Bootstrap] Preloader animation started');
        } else {
          console.warn('[Bootstrap] Preloader overlay not found when trying to initialize animation');
        }
      } catch (e) {
        console.error('[Bootstrap] Failed to initialize preloader animation:', e);
        console.error('[Bootstrap] Error details:', e.message, e.stack);
        // Preloader is already visible, so we continue without animation
        // BUT: Try to manually show text even if module failed
        const overlayEl = document.getElementById('preloader-overlay');
        if (overlayEl) {
          const mainText = overlayEl.querySelector('#main');
          const shadowText = overlayEl.querySelector('#shadow');
          if (mainText) {
            mainText.style.strokeDashoffset = '0';
            console.log('[Bootstrap] Preloader text manually shown (module failed)');
          }
          if (shadowText) {
            shadowText.style.strokeDashoffset = '0';
          }
        }
      }
    })();
    
    // Store hidePreloaderFn in a way that's accessible later
    // We'll update it when module loads
    const updateHidePreloaderFn = (fn) => {
      hidePreloaderFn = fn;
    };
    
    // Continue with other imports immediately (don't wait for preloader module)
    
    console.log('[Bootstrap] Importing THREE via importmap...');
    const THREE = await import('three');
    console.log('‚úì THREE imported');
    // NOTE: Preloader will be hidden after theme fully mounts (see below)
    
    // Make available globally for modules
    window.THREE = THREE;
    
    console.log('[Bootstrap] Importing modules...');
    // Use base path for all imports (already defined above)
    
    const { createEngine } = await import(`${base}/core/engine.js?v=38`);
    const { initThemeSwitcher, toggleTheme } = await import(`${base}/ui/themeSwitcher.js?v=38`);
    const { initHUD } = await import(`${base}/core/hud-manager.js?v=48`);
    const { initTheme, setEngine, getCurrentThemeId } = await import(`${base}/ui/theme-controller.js`);
    
    // ===== PHASE B: Expose theme functions globally for HUD =====
    // CRITICAL: All theme functions must be exposed BEFORE HUD initialization
    // This eliminates the need for dynamic imports in hud-manager.js
    if (typeof getCurrentThemeId === 'function') {
      window.getCurrentThemeId = getCurrentThemeId;
      console.log('[Bootstrap] window.getCurrentThemeId exposed:', typeof window.getCurrentThemeId);
    } else {
      console.error('[Bootstrap] getCurrentThemeId is not a function!');
    }
    
    // Initialize theme FIRST (before creating engine)
    // This applies CSS classes and ensures theme variables are available
    console.log('[Bootstrap] Initializing theme...');
    initTheme(); // Reads from localStorage/hash and applies theme
    
    // Force CSS recalculation to ensure theme variables are available
    document.documentElement.offsetHeight; // Force reflow
    
    console.log('[Bootstrap] Creating engine...');
    const engine = createEngine({
      canvasParent: document.getElementById('three-container'),
      labelsElement: document.getElementById('labels')
    });
    
    // Set engine reference in theme controller
    setEngine(engine);
    
    // Ensure engine scene background matches current theme immediately
    try {
      const { getSceneColors } = await import(`${base}/core/theme-colors.js?v=3`);
      const sceneColors = getSceneColors();
      if (engine.scene && engine.scene.background) {
        engine.scene.background = new THREE.Color(sceneColors.background);
      }
    } catch (e) {
      console.warn('[Bootstrap] Could not update scene background:', e);
    }
    
    // NOTE: Preloader will be hidden after theme fully mounts (see below)
    // Expose engine for grid overlay to query current scene state
    try { window._engine = engine; } catch(_) {}
    
    // PHASE 3 FIX: Register themeMounted listener BEFORE initThemeSwitcher to ensure it catches the event
    // Listen for theme mounted event
    // HUD is initialized early, but we need to update it with nodes after scene is mounted
    engine.on('themeMounted', async ({ themeId }) => {
      console.log('[Bootstrap] Theme mounted event received:', themeId);
      
      // Update HUD with nodes from mounted scene
      try {
        const plugin = engine.currentPlugin || window._calmPlugin;
        if (plugin && plugin.nodes) {
          console.log('[Bootstrap] Updating HUD with', plugin.nodes.length, 'nodes');
          // HUD should get nodes from engine, but we can also update it here
          // The nodes are already passed via initNavigationAndHUD, but let's ensure HUD has access
          if (typeof window._hud === 'object' && window._hud) {
            // HUD already has nodes from initNavigationAndHUD
            console.log('[Bootstrap] HUD already has nodes');
          }
        }
      } catch (e) {
        console.warn('[Bootstrap] Could not update HUD with nodes:', e);
      }
      
      // ===== –§–ê–ó–ê B: Bootstrap –ù–ï –º–∞–Ω–∏–ø—É–ª–∏—Ä—É–µ—Ç –∫–Ω–æ–ø–∫–æ–π —Ç–µ–º—ã –Ω–∞–ø—Ä—è–º—É—é =====
      // –ö–û–ù–¢–†–ê–ö–¢: Bootstrap –ù–ï –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∞ –∏–∑–º–µ–Ω—è—Ç—å #theme-toggle-btn –Ω–∞–ø—Ä—è–º—É—é
      // RESPONSIBILITY:
      //   - Bootstrap –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ –≤—ã–∑—ã–≤–∞—Ç—å HUD API –¥–ª—è —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏ –∫–Ω–æ–ø–∫–∏
      //   - –ù–ï –º–æ–∂–µ—Ç –º–µ–Ω—è—Ç—å display/visibility/opacity/pointer-events –Ω–∞–ø—Ä—è–º—É—é
      //   - –ù–ï –º–æ–∂–µ—Ç –∏—Å–∫–∞—Ç—å #theme-toggle-btn —á–µ—Ä–µ–∑ getElementById/querySelector
      //   - –ù–ï –º–æ–∂–µ—Ç –ø–µ—Ä–µ–º–µ—â–∞—Ç—å –∏–ª–∏ —É–¥–∞–ª—è—Ç—å –∫–Ω–æ–ø–∫—É
      // CRITICAL INVARIANT: –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–ª–∞–¥–µ–ª–µ—Ü #theme-toggle-btn ‚Äî HUD Manager
      // –§–ê–ó–ê B: –ò—Å–ø–æ–ª—å–∑—É–µ–º HUD API –≤–º–µ—Å—Ç–æ –ø—Ä—è–º—ã—Ö –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π
      try {
        if (window.hud && typeof window.hud.ensureThemeButton === 'function') {
          window.hud.ensureThemeButton();
          console.log('[Bootstrap] Theme button stabilized via HUD API after theme mount (–§–ê–ó–ê B: –∫–æ–Ω—Ç—Ä–∞–∫—Ç)');
        } else {
          console.warn('[Bootstrap] HUD API not available, cannot stabilize theme button');
        }
      } catch (e) {
        console.error('[Bootstrap] Error calling HUD API for theme button:', e);
      }
      
      // Hide preloader when the first theme fully mounts
      // Unified hide function with fallback
      const hidePreloaderWithFallback = async () => {
        try {
          // Wait for preloader module to load (if still loading)
          await preloaderInitPromise.catch(() => {}); // Ignore errors, we have fallback
          
          // Get hidePreloaderFn from module if available
          if (!hidePreloaderFn) {
            try {
              const preloaderModule = await import(`${base}/core/preloader.js`);
              hidePreloaderFn = preloaderModule.hidePreloader;
            } catch (e) {
              // Module not available, will use fallback
            }
          }
          
          // Calculate minimum display time (ensure at least 1 second visible)
          const preloaderStartTime = window.__PRELOADER_START_TIME__ || performance.now();
          const elapsed = performance.now() - preloaderStartTime;
          const minDisplayTime = 1000; // Minimum 1 second
          const delay = Math.max(150, minDisplayTime - elapsed);
          
          console.log('[Bootstrap] Preloader display time:', elapsed.toFixed(0), 'ms, delay:', delay.toFixed(0), 'ms');
          
          setTimeout(() => {
            const overlay = document.getElementById('preloader-overlay');
            if (!overlay) return;
            
            if (hidePreloaderFn && typeof hidePreloaderFn === 'function') {
              hidePreloaderFn();
              console.log('[Bootstrap] Preloader hidden via module');
            } else {
              // Fallback: direct class manipulation
              // CRITICAL: Always remove preload lock
              try {
                document.documentElement.classList.remove('ux4ai-preload-lock');
                document.body.classList.remove('ux4ai-preload-lock');
              } catch (e) {
                console.warn('[Bootstrap] Error removing preload lock in fallback:', e);
              }
              
              overlay.classList.add('hidden');
              
              // Remove inline styles after hiding
              setTimeout(() => {
                if (overlay) {
                  try {
                    overlay.style.cssText = '';
                  } catch (e) {
                    console.warn('[Bootstrap] Error clearing inline styles in fallback:', e);
                  }
                }
              }, 50);
              
              // Remove from DOM after animation
              setTimeout(() => {
                if (overlay && overlay.parentNode) {
                  try {
                    overlay.remove();
                  } catch (e) {
                    console.warn('[Bootstrap] Error removing overlay in fallback:', e);
                  }
                }
              }, 700);
              console.log('[Bootstrap] Preloader hidden via fallback');
            }
          }, delay);
        } catch (e) {
          console.error('[Bootstrap] Error hiding preloader:', e);
          // Last resort fallback
          // CRITICAL: Always remove preload lock
          try {
            document.documentElement.classList.remove('ux4ai-preload-lock');
            document.body.classList.remove('ux4ai-preload-lock');
          } catch (err) {
            console.warn('[Bootstrap] Error removing preload lock in last resort fallback:', err);
          }
          
          const overlay = document.getElementById('preloader-overlay');
          if (overlay) {
            overlay.classList.add('hidden');
            
            // Remove inline styles after hiding
            setTimeout(() => {
              if (overlay) {
                try {
                  overlay.style.cssText = '';
                } catch (err) {
                  console.warn('[Bootstrap] Error clearing inline styles in last resort fallback:', err);
                }
              }
            }, 50);
            
            setTimeout(() => {
              if (overlay && overlay.parentNode) {
                try {
                  overlay.remove();
                } catch (err) {
                  console.warn('[Bootstrap] Error removing overlay in last resort fallback:', err);
                }
              }
            }, 700);
          }
        }
      };
      
      // Hide on themeMounted (primary mechanism)
      hidePreloaderWithFallback();
    });
    
    // Initialize theme switcher (mounts scene ONCE)
    console.log('[Bootstrap] Initializing theme switcher...');
    initThemeSwitcher(engine);
    
    // ===== PHASE B: Expose toggleTheme globally for HUD =====
    // CRITICAL: Must be set synchronously before HUD initialization
    // This eliminates the need for dynamic imports in hud-manager.js
    if (typeof toggleTheme === 'function') {
      window.toggleTheme = toggleTheme;
      console.log('[Bootstrap] window.toggleTheme exposed:', typeof window.toggleTheme);
      // Verify function is actually callable
      if (typeof window.toggleTheme !== 'function') {
        console.error('[Bootstrap] CRITICAL: window.toggleTheme was set but is not a function!');
      }
    } else {
      console.error('[Bootstrap] toggleTheme is not a function! Module may have failed to load.');
      console.error('[Bootstrap] toggleTheme type:', typeof toggleTheme);
      console.error('[Bootstrap] toggleTheme value:', toggleTheme);
    }
    console.log('[Bootstrap] All theme functions available:', {
      getCurrentThemeId: typeof window.getCurrentThemeId,
      toggleTheme: typeof window.toggleTheme
    });
    
    // NOTE: HUD will be initialized in engine.initNavigationAndHUD() after scene is mounted
    // This ensures HUD has access to nodes from the scene
    // We don't initialize HUD here to avoid double initialization
    console.log('[Bootstrap] HUD will be initialized after scene is mounted');
    
    // ===== –§–ê–ó–ê B: Tour Restart Button - Bootstrap Creation =====
    // OWNER: Bootstrap (index.html) - ONLY responsible for creating #tour-restart-btn
    // RESPONSIBILITY:
    //   - Creates #tour-restart-btn ONCE
    //   - Attaches click/keydown handlers ONCE
    //   - NEVER touches #theme-toggle-btn or any other children of #theme-toggle-container
    //   - NEVER removes, recreates, or moves other elements
    // TOUR RESPONSIBILITY (separate):
    //   - Manages visibility (style.display) via showTour/hideTour functions
    //   - NEVER recreates or moves the button
    //   - NEVER touches #theme-toggle-btn (–∂—ë—Å—Ç–∫–∏–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç –§–∞–∑–∞ B)
    //
    // –§–ê–ó–ê B: –ñ–Å–°–¢–ö–ò–ô –ö–û–ù–¢–†–ê–ö–¢
    // –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–ª–∞–¥–µ–ª–µ—Ü #theme-toggle-btn ‚Äî HUD (core/hud-manager.js).
    // Bootstrap –ù–ï –º–æ–∂–µ—Ç –∏—Å–∫–∞—Ç—å #theme-toggle-btn —á–µ—Ä–µ–∑ getElementById/querySelector
    // Bootstrap –ù–ï –º–æ–∂–µ—Ç –º–µ–Ω—è—Ç—å display/visibility/opacity/pointer-events –Ω–∞–ø—Ä—è–º—É—é
    // Bootstrap –ù–ï –º–æ–∂–µ—Ç –ø–µ—Ä–µ–º–µ—â–∞—Ç—å –∏–ª–∏ —É–¥–∞–ª—è—Ç—å –∫–Ω–æ–ø–∫—É
    // Bootstrap –º–æ–∂–µ—Ç –¢–û–õ–¨–ö–û –≤—ã–∑—ã–≤–∞—Ç—å window.hud.ensureThemeButton() –¥–ª—è —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏
    try {
      const header = document.getElementById('site-header');
      if (header) {
        // PHASE TT1: Check if button already exists (idempotent creation)
        let btn = document.getElementById('tour-restart-btn');
        if (!btn) {
          // PHASE TT1: Create button ONCE - this is the single source of creation
          btn = document.createElement('button');
          btn.id = 'tour-restart-btn';
          btn.className = 'header-btn';
          btn.setAttribute('aria-label', '–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç—É—Ä');
          btn.title = '–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç—É—Ä';
          btn.tabIndex = 0;
          btn.textContent = '–ü—É—Å–∫';
          btn.style.display = 'inline-flex';
          
          // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü header (–ø–æ—Å–ª–µ theme-toggle-btn)
          header.appendChild(btn);
          console.log('[Bootstrap] Tour restart button created');
        } else {
          // Button already exists - just ensure it's visible
          btn.style.display = 'inline-flex';
        }
        
        // PHASE TT1: Set initial visibility (tour is closed by default)
        // CRITICAL: Only modifies tour-restart-btn, never touches theme-toggle-btn
        btn.style.display = 'inline-flex';
        
        // Analytics: view when in viewport (not self-healing, just analytics)
        try {
          const io = new IntersectionObserver((entries)=>{
            entries.forEach(en=>{ if (en.isIntersecting) { console.log('analytics: tour_restart_icon_view'); io.disconnect(); } });
          });
          io.observe(btn);
        } catch {}
        
        // ===== PHASE TT3: Tour Restart Button Click Handler - Absolutely Clean =====
        // OWNER: Bootstrap (index.html) - ONLY handles tour restart button clicks
        // RESPONSIBILITY:
        //   - Ignores non-relevant keys (only Enter/Space)
        //   - Checks if tour overlay is already open (prevents double-click)
        //   - Calls window.tour_reset() ONCE
        //   - Prevents default and stops propagation
        // CRITICAL INVARIANTS:
        //   - NO imports of themeSwitcher/theme-controller
        //   - NO access to #theme-toggle-btn
        //   - NO logic to "fix header/buttons"
        //   - NO side effects on theme, HUD, or any other elements
        const onActivate = (e) => {
          // PHASE TT3: Ignore non-relevant keys (only Enter and Space activate)
          if (e.type === 'keydown' && !(e.key === 'Enter' || e.key === ' ')) {
            return;
          }
          
          // PHASE TT3: Check if tour overlay is already open (prevent double-click issues)
          // CRITICAL: Only checks tour-overlay state, does NOT touch other elements
          const overlayActive = !!(document.getElementById('tour-overlay') && 
                                   !document.getElementById('tour-overlay').classList.contains('hidden'));
          if (overlayActive) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          
          // PHASE TT3: Call window.tour_reset() ONCE - tour will manage button visibility
          // CRITICAL: Does NOT switch theme, does NOT touch theme-toggle-btn, does NOT touch HUD
          // CRITICAL: No imports, no side effects, only tour restart
          if (typeof window.tour_reset === 'function') {
            window.tour_reset();
          } else {
            console.error('[Tour] window.tour_reset is not available, tour cannot be restarted');
          }
          
          // PHASE TT3: Prevent default and stop propagation for complete isolation
          e.preventDefault();
          e.stopPropagation();
        };
        
        // PHASE TT3: Attach ONLY these two event listeners - no others
        // CRITICAL: No additional listeners that could trigger theme or HUD logic
        btn.addEventListener('click', onActivate);
        btn.addEventListener('keydown', onActivate);
        
        // PHASE TT1: No self-healing, no MutationObserver, no hashchange/storage listeners
        // Button is created once in bootstrap, tour manages visibility via showTour/hideTour
        // CRITICAL: Bootstrap never touches theme-toggle-btn or any other children
      }
    } catch (e) {
      console.error('[Bootstrap] Failed to create tour restart button:', e);
    }
    
    // PHASE 3 FIX: Listener already registered above (before initThemeSwitcher)
    // This duplicate registration is removed to avoid double handling
    
    console.log('[Bootstrap] ‚úÖ Ready!');
    
    // Fallback mechanisms for hiding preloader (if themeMounted doesn't fire)
    // 1. window.load fallback (after 3 seconds from load)
    window.addEventListener('load', () => {
      loadFallbackTimeout = setTimeout(() => {
        const overlay = document.getElementById('preloader-overlay');
        if (overlay && !overlay.classList.contains('hidden')) {
          console.warn('[Bootstrap] Preloader still visible after window.load, hiding via fallback');
          
          // CRITICAL: Always remove preload lock
          try {
            document.documentElement.classList.remove('ux4ai-preload-lock');
            document.body.classList.remove('ux4ai-preload-lock');
          } catch (e) {
            console.warn('[Bootstrap] Error removing preload lock in window.load fallback:', e);
          }
          
          const elapsed = performance.now() - (window.__PRELOADER_START_TIME__ || 0);
          const delay = Math.max(0, 1000 - elapsed);
          setTimeout(() => {
            overlay.classList.add('hidden');
            
            // Remove inline styles after hiding
            setTimeout(() => {
              if (overlay) {
                try {
                  overlay.style.cssText = '';
                } catch (e) {
                  console.warn('[Bootstrap] Error clearing inline styles in window.load fallback:', e);
                }
              }
            }, 50);
            
            setTimeout(() => {
              if (overlay && overlay.parentNode) {
                try {
                  overlay.remove();
                } catch (e) {
                  console.warn('[Bootstrap] Error removing overlay in window.load fallback:', e);
                }
              }
            }, 700);
          }, delay);
        }
      }, 3000); // Wait 3 seconds after load
    });
    
    // 2. Hard timeout fallback (5 seconds max)
    setTimeout(() => {
      // CRITICAL: Always remove preload lock
      try {
        document.documentElement.classList.remove('ux4ai-preload-lock');
        document.body.classList.remove('ux4ai-preload-lock');
      } catch (e) {
        console.warn('[Bootstrap] Error removing preload lock in 5s timeout fallback:', e);
      }
      
      const overlay = document.getElementById('preloader-overlay');
      if (overlay && !overlay.classList.contains('hidden')) {
        console.warn('[Bootstrap] Preloader still visible after 5 seconds, forcing hide');
        overlay.classList.add('hidden');
        
        // Remove inline styles after hiding
        setTimeout(() => {
          if (overlay) {
            try {
              overlay.style.cssText = '';
            } catch (e) {
              console.warn('[Bootstrap] Error clearing inline styles in 5s timeout fallback:', e);
            }
          }
        }, 50);
        
        setTimeout(() => {
          if (overlay && overlay.parentNode) {
            try {
              overlay.remove();
            } catch (e) {
              console.warn('[Bootstrap] Error removing overlay in 5s timeout fallback:', e);
            }
          }
        }, 700);
      }
      // Clear load fallback if it's still pending
      if (loadFallbackTimeout) {
        clearTimeout(loadFallbackTimeout);
      }
    }, 5000);

    // ===== Guided Tour (PHASE 3: Using tour module) =====
    (async function initGuidedTour(){
      try {
        // Import tour module
        const base = window.__UX4AI_BASE_PATH__ || '';
        const { initTour, TOUR_STEPS } = await import(`${base}/core/tour.js?v=4`);
        
        // Parse URL parameters
      const params = new URLSearchParams(location.search);
      const tourOff = params.get('tour') === 'off';
      if (params.get('tour') === 'reset') {
              try { 
                localStorage.removeItem('tour_done'); 
                localStorage.removeItem('tour_step');
          } catch {}
        }
        const done = (typeof localStorage !== 'undefined') ? localStorage.getItem('tour_done') : null;
        const tourDone = done === '1';
        
        // Initialize tour module
        const tour = initTour({ tourOff, tourDone });
        
        if (!tour) {
          console.error('[Tour] Failed to initialize tour module');
              return;
            }
        
        // Export tour API to window - CRITICAL: Must be set before any tour button clicks
        window.tour_reset = tour.tour_reset;
        window.showTour = tour.showTour;
        window.hideTour = tour.hideTour;
        window.setTourStep = tour.setStep;
        window.startTour = tour.startTour;
        console.log('[Tour] Tour API exported to window:', {
          hasTourReset: typeof window.tour_reset === 'function',
          hasStartTour: typeof window.startTour === 'function'
        });
        
        // Export steps for fallback (if needed)
        try {
          window.tourSteps = TOUR_STEPS;
        } catch (e) {
          console.warn('[Tour] Could not export tourSteps:', e);
        }
        
        // Setup close button handler
      try { 
        const closeBtn = document.getElementById('tour-close'); 
        if (closeBtn) { 
          let closeBtnProcessing = false;
          const isMobileCloseBtn = window.innerWidth <= 767;
          const handleCloseBtnAction = (e) => {
            if (closeBtnProcessing) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            closeBtnProcessing = true;
            e.preventDefault();
            e.stopPropagation();
              tour.dismissTour();
            setTimeout(() => { closeBtnProcessing = false; }, 50);
          };
          if (isMobileCloseBtn) {
            closeBtn.addEventListener('touchstart', handleCloseBtnAction, { passive: false });
          } else {
            closeBtn.addEventListener('click', handleCloseBtnAction);
          }
            closeBtn.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault(); 
                tour.dismissTour();
            } 
          }); 
        } 
        } catch (e) {
          console.warn('[Tour] Could not setup close button:', e);
        }
        
        // Utility function to wait for CSS to be loaded
        // Simplified: only check if stylesheets exist (don't try to read rules due to CORS issues with Service Worker)
        const waitForCSS = (timeout = 2000) => {
          return new Promise((resolve) => {
            const startTime = performance.now();
            
            const checkCSS = () => {
              const stylesheets = Array.from(document.styleSheets);
              const requiredCSS = ['tokens.css', 'main.css'];
              
              // Check if stylesheets exist (don't try to read rules - CORS can block it with Service Worker)
              const loaded = requiredCSS.every(required => {
                return stylesheets.some(s => {
                  try {
                    return s.href && s.href.includes(required);
                  } catch (e) {
                    return false;
                  }
                });
              });
              
              if (loaded) {
                // CSS files are present, wait for styles to be applied
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    resolve();
                  });
                });
                return;
              }
              
              // Check timeout
              const elapsed = performance.now() - startTime;
              if (elapsed >= timeout) {
                console.warn('[Tour] CSS loading timeout, proceeding anyway');
                resolve();
                return;
              }
              
              // Retry after a short delay
              setTimeout(checkCSS, 50);
            };
            
            checkCSS();
          });
        };
        
        // Schedule display as soon as preloader hides AND CSS is loaded
        const tryShow = async () => {
          const preHidden = !document.getElementById('preloader-overlay') || document.getElementById('preloader-overlay').classList.contains('hidden');
          if (!preHidden) {
            setTimeout(tryShow, 120);
            return;
          }
          
          // Wait for CSS to be loaded and applied before starting tour
          await waitForCSS();
          
          const step = Number((typeof localStorage !== 'undefined' && localStorage.getItem('tour_step')) || '1') || 1;
          console.log('[Tour] CSS loaded and applied, starting tour from step:', step);
          const started = tour.startTour(step);
          if (!started) {
            console.error('[Tour] Failed to start tour on page load. Check console for detailed error messages from tour module.');
          } else {
            console.log('[Tour] Tour started successfully from step:', step);
          }
        };
      tryShow();
        
        console.log('[Tour] Tour module initialized successfully');
      } catch (e) {
        console.error('[Tour] Failed to initialize tour module:', e);
      }
    })();

    // Ensure any prior custom cursor element is removed
    try { const old = document.getElementById('custom-cursor'); if (old) old.remove(); } catch(_) {}

    // -------- HUD Grid (through-borders) ----------
    // Renders 1px lines across the whole viewport at the edges of HUD panels.
    // PHASE 3C: Read grid color from CSS variable with fallback
    const getCSSVariable = (name, fallback) => {
      try {
        const value = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return value || fallback;
      } catch (e) {
        return fallback;
      }
    };
    const GRID_COLOR = getCSSVariable('--grid-color', 'rgba(120, 220, 255, 0.25)');
    const gridOverlay = document.getElementById('grid-overlay');
    gridOverlay.style.position = 'fixed';
    gridOverlay.style.inset = '0';
    gridOverlay.style.pointerEvents = 'none';
    gridOverlay.style.zIndex = '850'; // above scene, below labels/HUD
    // Disable DOM-line overlay; we will draw via canvas for reliable animation
    gridOverlay.style.display = 'none';

    // Canvas grid overlay (reliable, animated in sync with core pulse)
    const canvas = document.getElementById('grid-canvas');
    const canvasBg = document.getElementById('grid-canvas-bg');
    canvas.style.position = 'fixed';
    canvas.style.inset = '0';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = '1100'; // Edge lines ABOVE panels (1000) and overlay
    if (canvasBg) {
      canvasBg.style.position = 'fixed';
      canvasBg.style.inset = '0';
      canvasBg.style.pointerEvents = 'none';
      canvasBg.style.zIndex = '930'; // Full grid BELOW backdrop (940)
    }
    // Grid only active in HUD mode or during tour
    function isGridActive() {
      const root = document.documentElement;
      const tourOverlay = document.getElementById('tour-overlay');
      const tourActive = tourOverlay && !tourOverlay.classList.contains('hidden');
      return root.classList.contains('hud-active') || root.classList.contains('links-active') || tourActive;
    }
    var GRID_SIMPLE = false; // bind to Calm wireframe
    let ctx = canvas.getContext('2d');
    let ctxBg = canvasBg ? canvasBg.getContext('2d') : null;
    // Flicker state synced to Calm intensity
    var _flicker = {
      lastI: 0,
      peaks: [], // {t0, dur, amp}
      activeUntil: 0,
      seed: Math.random()*1000
    };

    const LINE_THICK = 1; // px
    const targetsSelectors = [
      '#site-header',
      '#links-panel',
      '#hud-container',
      '#hud-small-panel',
      '#hud-big-panel',
      '#mobile-orbit-toggle'
    ];

    function clearLines() {
      while (gridOverlay.firstChild) gridOverlay.removeChild(gridOverlay.firstChild);
      // OPTIMIZATION: Invalidate engine's grid cache when lines are cleared
      // This prevents engine from trying to update deleted DOM elements
      if (typeof window !== 'undefined') {
        window._gridCacheInvalid = true;
      }
    }

    function addLine(x, y, w, h) {
      const dpr = window.devicePixelRatio || 1;
      const el = document.createElement('div');
      el.style.position = 'absolute';
      el.style.left = Math.floor(x) + 'px';
      el.style.top = Math.floor(y) + 'px';
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      el.className = 'grid-line ' + (h === 1 ? 'h' : 'v');
      // randomize dash/gap/phase so lines are desynchronized
      const rand = (min, max) => Math.random() * (max - min) + min;
      const dash = Math.round(rand(6, 14));
      const gap = Math.round(rand(6, 12));
      const phase = Math.round(rand(0, dash + gap));
      el.style.setProperty('--dash', dash + 'px');
      el.style.setProperty('--gap', gap + 'px');
      el.style.setProperty('--phase', phase + 'px');
      // crisp lines on fractional edges and high-DPI
      const fx = x - Math.floor(x);
      const fy = y - Math.floor(y);
      let tx = 0, ty = 0;
      if (Math.abs(fx - 0.5) < 0.26) tx = 0.5; // snap ~*.5px
      if (Math.abs(fy - 0.5) < 0.26) ty = 0.5;
      // On odd DPR physically shift lines by half pixel to sit on device pixel grid
      if (dpr % 2 !== 0) {
        if (w === 1) tx = tx || 0.5;
        if (h === 1) ty = ty || 0.5;
      }
      if (tx || ty) el.style.transform = `translate(${tx}px, ${ty}px)`;
      gridOverlay.appendChild(el);
    }

    // Cache arrays for canvas drawing (declared early so buildGrid can fill them)
    let cachedXs = [], cachedYs = [], lineSeeds = new Map();
    let lineDirsX = [], lineDirsY = [];
    let prevFlashActive = false;
    // (grid cursor crosshair disabled)

    function buildGrid() {
      if (!isGridActive()) return;
      clearLines();
      const rects = [];
      // During tour, build grid for entire viewport (visible through overlays)
      const tourOverlay = document.getElementById('tour-overlay');
      const tourActive = tourOverlay && !tourOverlay.classList.contains('hidden');
      if (tourActive) {
        // For tour, create a full-screen grid with 24px spacing (like HUD mode)
        // This will be visible through the transparent card
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const GRID_STEP = 24;
        // Generate grid lines across entire viewport
        const gridXs = new Set();
        const gridYs = new Set();
        for (let x = 0; x <= vw; x += GRID_STEP) {
          gridXs.add(x);
        }
        for (let y = 0; y <= vh; y += GRID_STEP) {
          gridYs.add(y);
        }
        // Store for drawing (will be used in drawCanvasGrid)
        cachedXs = Array.from(gridXs).sort((a,b)=>a-b);
        cachedYs = Array.from(gridYs).sort((a,b)=>a-b);
        // Assign random seeds for flicker
        lineSeeds = new Map();
        cachedXs.forEach((x,i)=> lineSeeds.set('x'+i, Math.random()));
        cachedYs.forEach((y,i)=> lineSeeds.set('y'+i, Math.random()));
        return; // Skip normal grid building for tour
      } else {
        // Normal HUD mode: build grid around specific elements
        targetsSelectors.forEach(sel => {
          const el = document.querySelector(sel);
          if (!el) return;
          const r = el.getBoundingClientRect();
          if (r.width > 0 && r.height > 0) rects.push(r);
          // —Ç–∞–∫–∂–µ —É—á–µ—Å—Ç—å –ø—Ä—è–º—ã—Ö –¥–µ—Ç–µ–π (—Å—Ç—Ä–æ–∫–∏/–∫–∞—Ä—Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ –º–∞–ª–æ–≥–æ HUD)
          if (el.id === 'hud-small-panel') {
            el.childNodes.forEach(n => {
              if (n.nodeType !== 1) return;
              const rr = n.getBoundingClientRect();
              if (rr.width > 0 && rr.height > 0) rects.push(rr);
            });
          }
        });
      }
      if (rects.length === 0) return;

      // –°–æ–±–∏—Ä–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ X/Y –∫—Ä–∞—ë–≤
      const xs = new Set();
      const ys = new Set();
      rects.forEach(r => {
        const left = r.left;
        const right = r.right - LINE_THICK;   // align to the visible right border
        const top = r.top;
        const bottom = r.bottom - LINE_THICK; // align to the visible bottom border
        xs.add(left);
        xs.add(right);
        ys.add(top);
        ys.add(bottom);
      });

      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const isMobile = vw <= 767;
      // Compute canvas size with device pixel ratio for crisp 1px strokes
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(vw * dpr);
      canvas.height = Math.floor(vh * dpr);
      canvas.style.width = vw + 'px';
      canvas.style.height = vh + 'px';
      ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Cache edges for canvas drawing
      // Exclude the area next to the scrollbar (avoid rightmost vertical line)
      // On mobile: no scrollbar, use smaller gutter
      const rightGutter = isMobile ? 2 : 18;
      // On mobile: allow lines closer to edges (panels are full-width)
      const minX = isMobile ? -1 : 0.5;
      cachedXs = Array.from(xs).sort((a,b)=>a-b).filter(x => x > minX && x < (vw - rightGutter));
      cachedYs = Array.from(ys).sort((a,b)=>a-b).filter(y => y > 0.5 && y < vh - 0.5);
      // assign random dash settings per line for desync
      lineSeeds = new Map();
      cachedXs.forEach((x,i)=> lineSeeds.set('x'+i, Math.random()));
      cachedYs.forEach((y,i)=> lineSeeds.set('y'+i, Math.random()));
      // initialize directions (+1/-1) per line
      lineDirsX = cachedXs.map(()=> (Math.random()<0.5? -1: 1));
      lineDirsY = cachedYs.map(()=> (Math.random()<0.5? -1: 1));
      drawCanvasGrid(0);
    }

    // –†–∏—Å—É–µ–º –ø–æ—Å–ª–µ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–º—ã (–Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∞–∫—Ç–æ–≤, —á—Ç–æ–±—ã —Å—Ö–≤–∞—Ç–∏—Ç—å –ø–æ–∑–¥–Ω–∏–µ —Ä–∞–∑–º–µ—Ä—ã)
    function scheduleBuildBurst() {
      buildGrid();
      requestAnimationFrame(buildGrid);
      setTimeout(buildGrid, 50);
      setTimeout(buildGrid, 150);
    }
    // Mobile HUD: keep 12px gap below site header
    function updateMobileHudTop(){
      try {
        const isMobile = window.innerWidth <= 479;
        const header = document.getElementById('site-header');
        const hudContainer = document.getElementById('hud-container');
        if (!header || !hudContainer) return;
        if (isMobile) {
          const h = Math.round(header.getBoundingClientRect().height || 0);
          hudContainer.style.setProperty('top', (h + 12) + 'px', 'important');
        } else {
          // restore desktop top from CSS
          hudContainer.style.removeProperty('top');
        }
      } catch {}
    }
    engine.on('themeMounted', () => {
      scheduleBuildBurst();
      updateMobileHudTop();
    });
    // Debounced resize handler for mobile HUD positioning
    let resizeHudTimeout = null;
    const debouncedUpdateMobileHudTop = () => {
      clearTimeout(resizeHudTimeout);
      resizeHudTimeout = setTimeout(() => {
        updateMobileHudTop();
      }, 150);
    };
    try { window.addEventListener('resize', debouncedUpdateMobileHudTop, { passive: true }); } catch {}

    // Initial draw at startup (before any theme mounts) so Calm scene shows lines
    scheduleBuildBurst();

    // --- Canvas drawing loop ---
    // Listen for Calm scene pulse events
    var pulseHueDeg = 200; var pulseUntilMs = 0; var forceStepUntilMs = 0;
    var pulseIntensity = null; // 0..1 from Calm
    // Synthetic flicker (working baseline): fast sine + noisy threshold, no scheduler
    var flashLevel = 0.12; // current alpha
    var lastMs = (typeof performance !== 'undefined') ? performance.now() : Date.now();
    var noiseSeed = Math.random()*1000;
    try {
      window.addEventListener('calmPulse', (e) => {
        const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
        const detail = (e && e.detail) || {};
        const hueDeg = (typeof detail.hueDeg === 'number') ? detail.hueDeg : 200;
        const inten = (typeof detail.intensity === 'number') ? Math.max(0, Math.min(1, detail.intensity)) : null;
        pulseHueDeg = hueDeg;
        pulseIntensity = inten;
        pulseUntilMs = now + 320; // longer 320ms flash for visibility
        forceStepUntilMs = pulseUntilMs;
      });
    } catch(_) {}
    function pulseColor(t){
      // Prefer Calm wireframe state if available
      let sceneHue = null; let sceneFlash = null; let sceneRgb = null; let sceneIntensity = null; let hasWF = false;
      let syntheticFlashActive = null;
      try {
        // Highest priority: direct Calm getter if present
        let wf = null;
        if (typeof window.__getCalmWireframeState === 'function') {
          wf = window.__getCalmWireframeState();
        } else if (window._calmPlugin && typeof window._calmPlugin.getWireframeState === 'function') {
          wf = window._calmPlugin.getWireframeState();
        } else if (window._engine && window._engine.currentPlugin && typeof window._engine.currentPlugin.getWireframeState === 'function') {
          wf = window._engine.currentPlugin.getWireframeState();
        }
        if (wf) {
          hasWF = true;
          if (typeof wf.hueDeg === 'number') sceneHue = wf.hueDeg;
          if (typeof wf.flash === 'number') sceneFlash = wf.flash;
          if (wf.rgb && typeof wf.rgb.r === 'number') sceneRgb = wf.rgb;
          if (typeof wf.intensity === 'number') sceneIntensity = Math.max(0, Math.min(1, wf.intensity));
        }
        // Fallback to Calm globals if plugin state is unavailable
        if (!hasWF && typeof window !== 'undefined') {
          if (typeof window._coreHueDeg === 'number') sceneHue = window._coreHueDeg;
          if (typeof window._corePulse === 'number') sceneIntensity = Math.max(0, Math.min(1, window._corePulse));
          if (typeof window._corePulseStep === 'number') sceneFlash = window._corePulseStep;
        }
        // Always read from Three.js scene by object name (authoritative if present)
        {
          const eng = window._engine;
          const obj = eng && eng.scene && typeof eng.scene.getObjectByName === 'function'
            ? eng.scene.getObjectByName('CalmCoreWire')
            : null;
          if (obj && obj.material) {
            const m = obj.material;
            if (typeof m.opacity === 'number') sceneIntensity = Math.max(0, Math.min(1, m.opacity));
            if (m.color) {
              const c = m.color;
              const max = Math.max(c.r, c.g, c.b), min = Math.min(c.r, c.g, c.b);
              let h = 200; const d = max - min;
              if (d > 1e-5) {
                if (max === c.r) h = ((c.g - c.b) / d) % 6;
                else if (max === c.g) h = (c.b - c.r) / d + 2;
                else h = (c.r - c.g) / d + 4;
                h *= 60; if (h < 0) h += 360;
              }
              sceneHue = h;
              sceneRgb = { r: Math.round(c.r*255), g: Math.round(c.g*255), b: Math.round(c.b*255) };
            }
          }
        }
      } catch(_) {}

      // If Calm is not providing state, synthesize it using the same style as Calm core
      const synthNeeded = !hasWF;
      if (synthNeeded) {
        // Synthetic color base (Calm core blue range)
        const tsec = t;
        const phase = 0.5 + 0.5*Math.sin(tsec * 0.60 * 2.0); // warpSpeed ~0.60
        const cO = { r: 0x58/255, g: 0xb7/255, b: 0xff/255 };
        const cI = { r: 0xa5/255, g: 0xf0/255, b: 0xff/255 };
        let baseR = (cO.r + (cI.r - cO.r) * phase) * 255;
        let baseG = (cO.g + (cI.g - cO.g) * phase) * 255;
        let baseB = (cO.b + (cI.b - cO.b) * phase) * 255;

        const nowMs = (typeof performance !== 'undefined') ? performance.now() : Date.now();
        const dt = Math.max(0, (nowMs - lastMs) / 1000);
        lastMs = nowMs;
        // Non-uniform threshold with noise; irregular but no scheduler
        const n = Math.sin(tsec*0.73 + noiseSeed) * 0.08; // slow noise
        const fast = Math.sin(tsec * 6.0 + Math.sin(tsec*1.5+noiseSeed)*0.33);
        const thr = 0.78 + n; // 0.70..0.86 jitter
        const isFlash = fast > thr;
        // Warm flash palette (yellow/orange/red blend)
        const warmMix = 0.5 + 0.5*Math.sin(tsec*3.1 + noiseSeed);
        const warmR = (0xff*(1-warmMix) + 0xff*warmMix);
        const warmG = (0xd2*(1-warmMix) + 0x4d*warmMix);
        const warmB = (0x4d*(1-warmMix) + 0x4d*warmMix);
        sceneRgb = isFlash
          ? { r: Math.round(warmR), g: Math.round(warmG), b: Math.round(warmB) }
          : { r: Math.round(baseR), g: Math.round(baseG), b: Math.round(baseB) };
        // Sharp rise/decay to targets
        const target = isFlash ? 0.28 : 0.10;
        const k = isFlash ? 22.0 : 12.0;
        flashLevel += (target - flashLevel) * (1 - Math.exp(-k*dt));
        const micro = Math.sin(tsec*37 + noiseSeed*2.3) * 0.012;
        sceneFlash = flashLevel + micro;
        syntheticFlashActive = isFlash;
        // Do not return here; continue to compute stroke below
      }

      // Visibility: if calmPulse window is active and carries intensity, use it strictly
      const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
      if (now < (pulseUntilMs||0) && typeof pulseIntensity === 'number') {
        // Step-like flash: no tails, slightly higher base
        const a = 0.16 + 0.22 * Math.max(0, Math.min(1, pulseIntensity));
        const hue = pulseHueDeg || 200;
        // Convert hue to RGB
        const H = ((hue % 360) + 360) % 360, S = 0.90, L = 0.70;
        const C = (1-Math.abs(2*L-1))*S; const X = C*(1-Math.abs(((H/60)%2)-1)); const m=L-C/2;
        let r1=0,g1=0,b1=0; const hSeg=Math.floor(H/60);
        if (hSeg===0){r1=C;g1=X;b1=0;} else if (hSeg===1){r1=X;g1=C;b1=0;} else if (hSeg===2){r1=0;g1=C;b1=X;} else if (hSeg===3){r1=0;g1=X;b1=C;} else if (hSeg===4){r1=X;g1=0;b1=C;} else {r1=C;g1=0;b1=X;}
        const rr = Math.round((r1+m)*255), gg = Math.round((g1+m)*255), bb = Math.round((b1+m)*255);
        return { stroke: `rgba(${rr},${gg},${bb},${a.toFixed(3)})`, p: 0, flashActive: true, alpha: a, hue: hue, intensity: pulseIntensity };
      }

      // Visibility: if we have sceneFlash as numeric alpha, use it; else step-only baseline
      let step = (typeof window !== 'undefined' && typeof window._corePulseStep === 'number') ? window._corePulseStep : null;
      let alpha;
      if (typeof sceneIntensity === 'number') {
        // Baseline strictly tied to Calm intensity (no randoms) ‚Äî slightly higher base
        alpha = 0.22 + 0.16 * sceneIntensity;
      } else {
        if (sceneFlash != null) step = sceneFlash;
        alpha = (step === 0 || step === 1) ? (step === 1 ? 0.65 : 0.24) : 0.24;
      }

      // Stroke color
      const computedFlashActive = (syntheticFlashActive !== null) ? syntheticFlashActive : (!!step);
      if (sceneRgb) {
        const { r, g, b } = sceneRgb;
        return { stroke: `rgba(${r},${g},${b},${alpha.toFixed(3)})`, p: 0, flashActive: computedFlashActive, alpha, hue: sceneHue, intensity: sceneIntensity };
      }

      // Fallback to hue
      const baseHue = (sceneHue != null) ? sceneHue : 200;
      const H = ((baseHue % 360) + 360) % 360, S = 0.90, L = 0.70;
      const C = (1-Math.abs(2*L-1))*S; const X = C*(1-Math.abs(((H/60)%2)-1)); const m=L-C/2;
      let r1=0,g1=0,b1=0; const hSeg=Math.floor(H/60);
      if (hSeg===0){r1=C;g1=X;b1=0;} else if (hSeg===1){r1=X;g1=C;b1=0;} else if (hSeg===2){r1=0;g1=C;b1=X;} else if (hSeg===3){r1=0;g1=X;b1=C;} else if (hSeg===4){r1=X;g1=0;b1=C;} else {r1=C;g1=0;b1=X;}
      const rr = Math.round((r1+m)*255), gg = Math.round((g1+m)*255), bb = Math.round((b1+m)*255);
      return { stroke: `rgba(${rr},${gg},${bb},${alpha.toFixed(3)})`, p: 0, flashActive: computedFlashActive, alpha, hue: baseHue, intensity: sceneIntensity };
    }
    function drawCanvasGrid(t){
      try {
        if (!ctx) return;
        const vw = window.innerWidth, vh = window.innerHeight;
        // Ensure canvas matches viewport even when HUD is inactive (for crosshair)
        const dpr = window.devicePixelRatio || 1;
        const needResize = canvas.width !== Math.floor(vw * dpr) || canvas.height !== Math.floor(vh * dpr);
        if (needResize) {
          canvas.width = Math.floor(vw * dpr);
          canvas.height = Math.floor(vh * dpr);
          canvas.style.width = vw + 'px';
          canvas.style.height = vh + 'px';
          ctx = canvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        // Sync background canvas size
        if (canvasBg && ctxBg) {
          const needResizeBg = canvasBg.width !== Math.floor(vw * dpr) || canvasBg.height !== Math.floor(vh * dpr);
          if (needResizeBg) {
            canvasBg.width = Math.floor(vw * dpr);
            canvasBg.height = Math.floor(vh * dpr);
            canvasBg.style.width = vw + 'px';
            canvasBg.style.height = vh + 'px';
            ctxBg = canvasBg.getContext('2d');
            ctxBg.setTransform(dpr, 0, 0, dpr, 0, 0);
          }
        }
        ctx.clearRect(0,0,vw,vh);
        const pc = pulseColor(t/1000);
        const nowFlash = !!pc.flashActive;
        prevFlashActive = nowFlash;
        const hudOrLinks = isGridActive();
        const linksActive = document.documentElement.classList.contains('links-active');
        const hudActiveFlag = document.documentElement.classList.contains('hud-active');
        const tourOverlayEl = document.getElementById('tour-overlay');
        const tourActive = tourOverlayEl && !tourOverlayEl.classList.contains('hidden');
        const hudOnly = hudActiveFlag && !linksActive && !tourActive;
        // PHASE 3C: Read grid line colors from CSS variables with fallback
        // Edge lines (above overlay) - use more transparent Edge tokens
        const baseBorderColor = getCSSVariable('--grid-line-edge-base', 'rgba(255,255,255,0.12)');
        const flashColor = getCSSVariable('--grid-line-edge-flash', 'rgba(255,255,255,0.50)');
        ctx.lineWidth = 1;
        if (hudOrLinks) {
          // Draw grid lines only in HUD/Links mode
          // Solid lines (no dash) with very subtle color flicker during flash (all lines)
          cachedXs.forEach((x,i)=>{
            const seed = lineSeeds.get('x'+i) || 0.5;
            let lineColor = baseBorderColor;
            if (nowFlash) {
              // Very subtle flicker - very slow and barely noticeable
              const freq = 12; // much slower frequency
              const duty = 0.15; // shorter flash duration
              const ph = (t*freq + seed*3) % 1;
              const strobeOn = ph < duty;
              lineColor = strobeOn ? flashColor : baseBorderColor;
            }
            ctx.strokeStyle = lineColor;
            ctx.setLineDash([]); // solid line
            ctx.beginPath();
            // half-pixel align for crispness
            ctx.moveTo(Math.round(x)+0.5, 0);
            ctx.lineTo(Math.round(x)+0.5, vh);
            ctx.stroke();
          });
          cachedYs.forEach((y,i)=>{
            const seed = lineSeeds.get('y'+i) || 0.5;
            let lineColor = baseBorderColor;
            if (nowFlash) {
              // Very subtle flicker - very slow and barely noticeable
              const freq = 12; // much slower frequency
              const duty = 0.15; // shorter flash duration
              const ph = (t*freq + seed*3.7) % 1; // slightly different seed
              const strobeOn = ph < duty;
              lineColor = strobeOn ? flashColor : baseBorderColor;
            }
            ctx.strokeStyle = lineColor;
            ctx.setLineDash([]); // solid line
            ctx.beginPath();
            ctx.moveTo(0, Math.round(y)+0.5);
            ctx.lineTo(vw, Math.round(y)+0.5);
            ctx.stroke();
          });
        }
        // Background grid under HUD overlay: full-screen grid like tour
        if (canvasBg && ctxBg) {
          ctxBg.clearRect(0,0,vw,vh);
          const isMobile = window.innerWidth <= 767;
          if (hudOnly || linksActive || tourActive || (isMobile && (hudActiveFlag || linksActive))) {
            // PHASE 3C: Read grid line colors from CSS variables with fallback
            const baseBorderColor = getCSSVariable('--grid-line-base', 'rgba(255,255,255,0.40)');
            const flashColor = tourActive 
              ? getCSSVariable('--grid-line-flash', 'rgba(255,255,255,0.95)')
              : getCSSVariable('--grid-line-flash-hud', 'rgba(255,255,255,0.90)');
            const step = 24;
            // subtle flicker synced with tour logic
            const freq = 12;
            const duty = 0.15;
            const doFlicker = nowFlash;
            // Vertical lines
            let i = 0;
            for (let x=0; x<=vw; x+=step, i++) {
              let color = baseBorderColor;
              if (doFlicker) {
                const seed = (i*0.173)%1; // deterministic seed per line
                const ph = (t*freq + seed*3) % 1;
                const strobeOn = ph < duty;
                color = strobeOn ? flashColor : baseBorderColor;
              }
              ctxBg.strokeStyle = color;
              ctxBg.setLineDash([]);
              ctxBg.beginPath();
              ctxBg.moveTo(Math.round(x)+0.5, 0);
              ctxBg.lineTo(Math.round(x)+0.5, vh);
              ctxBg.stroke();
            }
            // Horizontal lines
            i = 0;
            for (let y=0; y<=vh; y+=step, i++) {
              let color = baseBorderColor;
              if (doFlicker) {
                const seed = (i*0.237)%1;
                const ph = (t*freq + seed*3.7) % 1;
                const strobeOn = ph < duty;
                color = strobeOn ? flashColor : baseBorderColor;
              }
              ctxBg.strokeStyle = color;
              ctxBg.setLineDash([]);
              ctxBg.beginPath();
              ctxBg.moveTo(0, Math.round(y)+0.5);
              ctxBg.lineTo(vw, Math.round(y)+0.5);
              ctxBg.stroke();
            }
          }
        }

        // (tour grid canvas removed)
        // --- Cursor crosshair (subtle) ---
        // Fade crosshair when idle
        // (grid cursor crosshair removed)
        // Debug HUD removed per request
      } catch (_) { /* swallow to keep app alive */ }
      requestAnimationFrame(drawCanvasGrid);
    }

    // Start the draw loop on startup (even outside HUD)
    try { requestAnimationFrame(drawCanvasGrid); } catch(_) {}

    // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –Ω–∞ resize
    let gridTimer;
    window.addEventListener('resize', () => {
      clearTimeout(gridTimer);
      gridTimer = setTimeout(buildGrid, 100);
    });

    // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è layout HUD (display/–∫–ª–∞—Å—Å—ã/inline-—Å—Ç–∏–ª–∏)
    // Debounce –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    let gridBuildTimeout = null;
    const debouncedBuildGrid = () => {
      clearTimeout(gridBuildTimeout);
      const isMobile = window.innerWidth <= 767;
      const delay = isMobile ? 100 : 0; // –ó–∞–¥–µ—Ä–∂–∫–∞ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
      gridBuildTimeout = setTimeout(() => {
        buildGrid();
      }, delay);
    };
    const moTargets = ['#site-header', '#links-panel', '#hud-container', '#hud-small-panel', '#hud-big-panel', '#mobile-orbit-toggle']
      .map(sel => document.querySelector(sel)).filter(Boolean);
    if (moTargets.length) {
      const mo = new MutationObserver(debouncedBuildGrid);
      // OPTIMIZATION: Removed subtree: true to prevent infinite loop
      // Engine updates grid-line styles every frame, which was triggering MutationObserver
      // Only watch for class changes on the target elements themselves (display/visibility)
      moTargets.forEach(t => mo.observe(t, { attributes: true, attributeFilter: ['class'], subtree: false }));
    }
    // Watch for hud-active class changes on document root and tour overlay
    const hudObserver = new MutationObserver(() => {
      if (isGridActive()) {
        debouncedBuildGrid();
      } else {
        // Clear grid when HUD is inactive
        if (ctx) {
          const vw = window.innerWidth, vh = window.innerHeight;
          ctx.clearRect(0, 0, vw, vh);
        }
      }
    });
    // Also watch tour overlay for show/hide
    const tourOverlay = document.getElementById('tour-overlay');
    if (tourOverlay) {
      const tourObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            const isHidden = tourOverlay.classList.contains('hidden');
            // CRITICAL: Tour no longer modifies global classes
            // Removed: document.body.classList.remove('tour-active');
            // Removed: document.body.classList.add('tour-active');
            if (!isHidden) {
              debouncedBuildGrid(); // rebuild grid when tour opens
            }
            // Trigger grid rebuild
            if (isGridActive()) {
              debouncedBuildGrid();
            } else {
              if (ctx) {
                const vw = window.innerWidth, vh = window.innerHeight;
                ctx.clearRect(0, 0, vw, vh);
              }
            }
          }
        });
      });
      tourObserver.observe(tourOverlay, { attributes: true, attributeFilter: ['class'] });
    }
    hudObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
    
    // Resize handler
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        engine.resize(window.innerWidth, window.innerHeight);
      }, 250);
    });
    
    engine.resize(window.innerWidth, window.innerHeight);
    
    // DIAGNOSTIC: Log layout state at end of init()
    dumpLayoutSnapshot('end-of-init');
    
  } catch (error) {
    console.error('[Bootstrap] ‚ùå Error:', error);
    // Do not replace body; keep app visible for diagnostics
  }
}

init();
</script>
<!-- Service Worker Registration (disabled for local development to avoid stale CSS/theme cache) -->
<!--
<script>
  // Service Worker registration with update notification
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      // Use base path for Service Worker registration
      const swPath = (window.__UX4AI_BASE_PATH__ || '') + '/sw.js';
      console.log('[SW] Registering Service Worker at:', swPath);
      navigator.serviceWorker.register(swPath)
        .then((registration) => {
          console.log('[SW] Registered:', registration.scope);
          
          // Check for updates every 30 minutes
          setInterval(() => {
            registration.update();
          }, 30 * 60 * 1000);
          
          // Listen for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New version available - show notification, but don't auto-reload
                console.log('[SW] New version available');
                showUpdateNotification(newWorker);
              }
              // Removed auto-reload on activation to prevent reload loops
            });
          });
        })
        .catch((error) => {
          console.error('[SW] Registration failed:', error);
        });
      
      // Removed controllerchange listener to prevent reload loops
      // Users can manually reload if needed via update notification
    });
  }
  
  // Show update notification
  function showUpdateNotification(worker) {
    // PHASE 3E: Read colors from CSS variables with fallback
    const getCSSVariable = (name, fallback) => {
      try {
        const value = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return value || fallback;
      } catch (e) {
        return fallback;
      }
    };
    
    const bannerBg = getCSSVariable('--update-banner-bg', 'rgba(91, 156, 255, 0.95)');
    const bannerText = getCSSVariable('--update-banner-text', '#ffffff');
    const bannerShadow = getCSSVariable('--update-banner-shadow', 'rgba(0, 0, 0, 0.3)');
    const buttonBg = getCSSVariable('--update-banner-btn-bg', '#ffffff');
    const buttonText = getCSSVariable('--update-banner-btn-text', '#58A6FF');
    const buttonBorder = getCSSVariable('--update-banner-btn-border', 'rgba(255, 255, 255, 0.5)');
    
    // Create notification banner
    const banner = document.createElement('div');
    banner.id = 'update-banner';
    banner.style.cssText = `
      position: fixed;
      top: 56px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3000;
      background: ${bannerBg};
      color: ${bannerText};
      padding: 12px 24px;
      border-radius: 0;
      box-shadow: 0 4px 12px ${bannerShadow};
      display: flex;
      align-items: center;
      gap: 16px;
      font-family: ui-sans-serif, system-ui, sans-serif;
      font-size: 14px;
    `;
    
    banner.innerHTML = `
      <span>–î–æ—Å—Ç—É–ø–Ω–∞ –Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞</span>
      <button id="update-btn" style="
        padding: 6px 12px;
        background: ${buttonBg};
        color: ${buttonText};
        border: none;
        font-weight: 500;
        cursor: pointer;
      ">–û–±–Ω–æ–≤–∏—Ç—å</button>
      <button id="dismiss-btn" style="
        padding: 6px 12px;
        background: transparent;
        color: ${bannerText};
        border: 1px solid ${buttonBorder};
        font-weight: 500;
        cursor: pointer;
      ">–ü–æ–∑–∂–µ</button>
    `;
    
    document.body.appendChild(banner);
    
    // Update button
    document.getElementById('update-btn').addEventListener('click', () => {
      worker.postMessage({ type: 'SKIP_WAITING' });
      banner.remove();
    });
    
    // Dismiss button
    document.getElementById('dismiss-btn').addEventListener('click', () => {
      banner.remove();
    });
    
    // Analytics
    console.log('analytics: update_notification_shown');
  }
  
  // Force update function (accessible globally)
  window.forceUpdate = async function() {
    if ('serviceWorker' in navigator) {
      const registration = await navigator.serviceWorker.getRegistration();
      if (registration) {
        registration.unregister();
        caches.keys().then((names) => {
          names.forEach(name => caches.delete(name));
        });
        window.location.reload(true);
      }
    }
  };
</script>
-->
</body>
</html>

