<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Владимир Костял — UX4AI: UX-архитектура и интерфейсы для AI</title>
<meta name="description" content="Владимир Костял — проектирую UX-архитектуру и интерфейсы для AI‑сервисов. UX4AI: паттерны, подходы и решения для взаимодействия с ИИ."/>
<meta name="keywords" content="UX, AI, UX архитектура, интерфейсы, проектирование, взаимодействие с ИИ, UX4AI"/>
<link rel="canonical" href="https://ux4ai.pro/"/>

<!-- Open Graph -->
<meta property="og:type" content="website"/>
<meta property="og:url" content="https://ux4ai.pro/"/>
<meta property="og:site_name" content="Владимир Костял — UX4AI"/>
<meta property="og:title" content="Владимир Костял — UX4AI: UX-архитектура и интерфейсы для AI"/>
<meta property="og:description" content="Проектирую UX‑архитектуру и интерфейсы для AI‑сервисов. Паттерны, подходы и решения для взаимодействия с ИИ."/>
<!-- Open Graph images (multiple formats) -->
<meta property="og:image" content="https://ux4ai.pro/preview.webp?v=3"/>
<meta property="og:image:type" content="image/webp"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="630"/>
<meta property="og:image" content="https://ux4ai.pro/preview.png?v=3"/>
<meta property="og:image:type" content="image/png"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="630"/>
<meta property="og:image" content="https://ux4ai.pro/preview.jpg?v=3"/>
<meta property="og:image:type" content="image/jpeg"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="630"/>

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="Владимир Костял — UX4AI: UX-архитектура и интерфейсы для AI"/>
<meta name="twitter:description" content="Проектирую UX‑архитектуру и интерфейсы для AI‑сервисов. Паттерны, подходы и решения для взаимодействия с ИИ."/>
<meta name="twitter:image" content="https://ux4ai.pro/preview.webp?v=3"/>
<meta name="twitter:image:alt" content="UX4AI — UX-архитектура и интерфейсы для AI"/>

<!-- Verification (replace content values with real codes) -->
<meta name="google-site-verification" content="REPLACE_WITH_GOOGLE_CODE"/>
<meta name="yandex-verification" content="REPLACE_WITH_YANDEX_CODE"/>

<!-- Schema.org Person markup for better name discoverability -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Person",
  "name": "Владимир Костял",
  "url": "https://ux4ai.pro/",
  "jobTitle": "UX-архитектор",
  "worksFor": {
    "@type": "Organization",
    "name": "UX4AI"
  }
}
</script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105120842', 'ym');

    ym(105120842, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105120842" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
<!-- Favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="./favicon.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="./favicon.png"/>
<link rel="apple-touch-icon" sizes="180x180" href="./android-chrome-192x192.png"/>
<link rel="icon" type="image/png" sizes="192x192" href="./android-chrome-192x192.png"/>
<link rel="icon" type="image/png" sizes="512x512" href="./android-chrome-512x512.png"/>
<link rel="preload" href="./styles/variables.css" as="style"/>
<link rel="stylesheet" href="./styles/variables.css"/>
<!-- <link rel="preload" href="./styles/main.css" as="style"/> -->
<!-- <link rel="stylesheet" href="./styles/main.css"/> -->
<style>
    /* Scroll world: make body tall so camera flies segment-by-segment */
html {
  margin: 0;
  padding: 0;
  background: var(--bg);
  height: 100%;
  overflow-x: hidden;
  /* Establish consistent typography across the site: the base body text
     corresponds to Text/Body/Base (16px/24px) from the design system. */
  font-size: 16px;
  line-height: 1.5;
  font-weight: 400;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, sans-serif;
}
body {
  margin: 0;
  padding: 0;
  background: transparent;
  color: var(--text);
}
/* While orbit is active on mobile, block browser gestures (pan/zoom) */
.orbit-active, .orbit-active body, .orbit-active #three-container { touch-action: none; }
    /* Height is set dynamically based on segments; keep minimal here */
    #three-container { 
      position:fixed; 
      inset:0; 
      overflow:hidden; 
      background: transparent;
      z-index: 1;
    }
    #labels {
      position: fixed; 
      inset: 0; 
      pointer-events: none;
      background: transparent;
      z-index: 900;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial;
    }
    .label {
      position:absolute; transform:translate(-50%,-50%);
      padding: 4px 10px;
      pointer-events: auto;
      font-size: 14px;
      letter-spacing: 0.2px;
      font-weight: 400;
      color: var(--text);
      background: rgba(18,23,34,0.85);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 0 0 1px rgba(36,48,65,0.4) inset, 0 2px 10px rgba(0,0,0,0.25);
      white-space: nowrap;
      opacity: 0.96;
    }

    .label:hover {
      background: rgba(36, 48, 65, 0.95);
      border-color: var(--accent);
      color: #CFE8FF;
      cursor: pointer;
    }
    /* HUD chips (layer hints) preserved for orientation */
    .hud {
      position: fixed; left: 12px; top: 12px; right: 12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      background:#121722cc; border:1px solid var(--border); border-radius:12px; padding:8px 10px; backdrop-filter: blur(6px);
      z-index:10; font-size:12px;
    }
    .chip { padding:4px 8px; border:1px solid #2a3b51; border-radius:10px; background:#162032; opacity:0.96; }
    .spacer{flex:1}
    .hint {opacity:0.7}

    /* Overlay backdrop for node details. This layer darkens the background when a
       node is selected and enables clicks outside of the panels to close the
       overlay. */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.45);
      pointer-events: none; /* Always none - don't block clicks */
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 900;
    }
    /* In HUD we используем #hud-backdrop для затемнения, оставляем #overlay прозрачным для кликов */
    .hud-active #overlay { 
      background: transparent !important; 
      pointer-events: none !important; /* Ensure overlay never blocks clicks in HUD mode */
    }
    /* HUD backdrop (similar to tour backdrop) - shows when HUD is active */
    #hud-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(5,8,12,0.60);
      backdrop-filter: blur(2px) saturate(120%);
      z-index: 940;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s ease;
    }
    #hud-backdrop.hidden {
      display: none !important;
    }
    /* Hide overlay on mobile when not active */
    @media (max-width: 479px) {
      #overlay:not(.active) {
        display: none !important;
      }
      body {
        background: transparent !important;
      }
    }
    #overlay.active {
      pointer-events: none; /* Changed from auto to none - overlay should not block clicks */
      opacity: 1;
    }
    /* HUD backdrop should NOT block clicks - it's just visual */
    #hud-backdrop {
      pointer-events: none !important;
    }
    /* Hide unused legacy panels by default */
    #object-icon, #big-panel, #small-panel {
      display: none;
    }
    /* Detached HUD elements for the clicked node */
    #hud-object-icon {
      position: fixed;
      top: 200px;
      left: 450px;
      right: auto;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: var(--accent); /* will be overridden with the node's colour via JS */
      box-shadow: 0 0 20px rgba(91, 156, 255, 0.5);
      border: 3px solid var(--border);
      display: none;
      z-index: 1000;
    }
    #hud-big-panel {
      position: fixed;
      top: 200px;
      right: 450px;
      left: auto;
      width: 580px;
      max-height: calc(100vh - 250px) !important;  /* limit height to enable scroll */
      height: auto !important;
      overflow-y: auto !important;                /* enable scroll */
      overflow-x: hidden !important;            /* avoid nested horizontal scroll */
      overscroll-behavior: contain !important;  /* prevent scroll chaining */
      background: rgba(18, 23, 34, 0.35);
      backdrop-filter: blur(2px) saturate(140%);
      border: 1px solid #243041;
      border-radius: 12px;
      padding: 20px;
      color: #E6EEF8;
      line-height: 1.5;
      white-space: pre-line;
      box-sizing: border-box;        /* keep padding inside bounds */
      overflow-wrap: anywhere;       /* wrap long tokens */
      word-break: break-word;        /* break long words */
      font-weight: 200;
      display: none;
      z-index: 1000;
    }
    /* Ensure all text in big panel has consistent weight, except headings */
    #hud-big-panel * {
      font-weight: 200;
    }
    /* Override for headings */
    #hud-big-panel h1,
    #hud-big-panel h2,
    #hud-big-panel h3,
    #hud-big-panel h4,
    #hud-big-panel h5,
    #hud-big-panel h6 {
      font-weight: 600 !important;
    }
    /* Headings in big panel main text use tour style */
    #hud-big-panel h1,
    #hud-big-panel h2,
    #hud-big-panel h3,
    #hud-big-panel h4,
    #hud-big-panel h5,
    #hud-big-panel h6,
    .hud-active #hud-big-panel h1,
    .hud-active #hud-big-panel h2,
    .hud-active #hud-big-panel h3,
    .hud-active #hud-big-panel h4,
    .hud-active #hud-big-panel h5,
    .hud-active #hud-big-panel h6 {
      font: 600 20px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
    }
    /* Main heading (h2) - 10px margin bottom to paragraph */
    #hud-big-panel h2,
    .hud-active #hud-big-panel h2,
    #hud-container #hud-big-panel h2,
    .hud-active #hud-container #hud-big-panel h2 {
      margin: 0 0 10px 0 !important;
    }
    /* Subheadings (h3, h4) - smaller than main heading, no margin */
    #hud-big-panel h3,
    .hud-active #hud-big-panel h3,
    #hud-container #hud-big-panel h3,
    .hud-active #hud-container #hud-big-panel h3 {
      font: 600 18px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
    }
    #hud-big-panel h4,
    .hud-active #hud-big-panel h4,
    #hud-container #hud-big-panel h4,
    .hud-active #hud-container #hud-big-panel h4 {
      font: 600 16px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
    }
    /* Paragraph spacing: 20px between paragraphs */
    #hud-big-panel p,
    .hud-active #hud-big-panel p,
    #hud-container #hud-big-panel p,
    .hud-active #hud-container #hud-big-panel p {
      margin: 0 0 20px 0;
      line-height: 1.5;
    }
    #hud-big-panel p:last-child,
    .hud-active #hud-big-panel p:last-child,
    #hud-container #hud-big-panel p:last-child,
    .hud-active #hud-container #hud-big-panel p:last-child {
      margin-bottom: 0;  /* Убрать отступ у последнего абзаца */
    }
    /* Remove spacing after subheadings - no margin for first paragraph after h3/h4 */
    #hud-big-panel h3 + p,
    #hud-big-panel h4 + p,
    .hud-active #hud-big-panel h3 + p,
    .hud-active #hud-big-panel h4 + p,
    #hud-container #hud-big-panel h3 + p,
    #hud-container #hud-big-panel h4 + p,
    .hud-active #hud-container #hud-big-panel h3 + p,
    .hud-active #hud-container #hud-big-panel h4 + p {
      margin-top: 0;  /* Убрать отступ у первого абзаца после подзаголовка */
    }
    /* Hide scrollbar but keep scrolling */
    #hud-big-panel {
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE and Edge */
    }
    #hud-big-panel::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }
    #hud-small-panel {
      position: fixed;
      top: 200px;
      left: 450px;
      right: auto;
      width: 250px;
      display: none;
      flex-direction: column;
      align-items: stretch;
      gap: 12px;
      background: none;
      border: none;
      z-index: 1000;
    }
    #hud-small-panel, #hud-small-panel * { box-sizing: border-box; }
    /* Section header inside HUD (title, summary, prev/next) */
    #hud-small-panel .hud-section-header {
      width: 100%;
      text-align: left;
      color: #E6EEF8;
      background: rgba(18,23,34,0.35);
      backdrop-filter: blur(2px) saturate(140%);
      border: 1px solid var(--border);
      border-radius: 8px;
      
    }
    /* Block B: reset positioning when panels are inside the container (desktop) */
    #hud-container #hud-small-panel { position: static; width: 280px; }
    #hud-container #hud-big-panel { position: static; width: 580px; }

    /* HUD Container: fixed, centered wrapper to mirror working layout */
    #hud-container {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      display: none;              /* controlled by JS */
      flex-direction: row;
      gap: 24px;
      z-index: 1000;
    }
    /* Inside container: refine child layouts matching working variant */
    #hud-container #hud-small-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: none;
      border: none;
    }
    #hud-container #hud-big-panel {
      max-height: calc(100vh - 200px) !important;  /* limit height to enable scroll */
      height: auto !important;
      overflow-y: auto !important;                 /* enable scroll in container mode */
      overflow-x: hidden !important;            /* avoid nested horizontal scroll */
      overscroll-behavior: contain !important;  /* prevent scroll chaining */
      background: rgba(18, 23, 34, 0.35);
      backdrop-filter: blur(2px) saturate(140%);
      border: 1px solid #243041;
      border-radius: 12px;
      padding: 20px;
      color: #E6EEF8;
      line-height: 1.5;
      white-space: pre-line;
      box-sizing: border-box;        /* keep padding inside bounds */
      overflow-wrap: anywhere;       /* wrap long tokens */
      word-break: break-word;        /* break long words */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE and Edge */
    }
    #hud-container #hud-big-panel::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }
    /* Headings in container big panel main text use tour style */
    #hud-container #hud-big-panel h1,
    #hud-container #hud-big-panel h2,
    #hud-container #hud-big-panel h3,
    #hud-container #hud-big-panel h4,
    #hud-container #hud-big-panel h5,
    #hud-container #hud-big-panel h6,
    .hud-active #hud-container #hud-big-panel h1,
    .hud-active #hud-container #hud-big-panel h2,
    .hud-active #hud-container #hud-big-panel h3,
    .hud-active #hud-container #hud-big-panel h4,
    .hud-active #hud-container #hud-big-panel h5,
    .hud-active #hud-container #hud-big-panel h6 {
      font: 600 20px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
    }
    #hud-small-panel .hud-section-title {
      margin: 0 0 6px 0;
      
      font-weight: 400;
      color: #CFE8FF;
    }
    #hud-small-panel .hud-section-summary {
      margin: 10px 0 18px 0;  /* increased top and bottom margins by 10px */
      
      line-height: 1.4;
      color: #9AA6B2;
    }
    #hud-small-panel .hud-section-nav {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    #hud-small-panel .hud-section-nav a {
      font-size: 16px;
      font-weight: 200 !important;
      color: #9AA6B2 !important;  /* same color as links panel */
      text-decoration: none;
      padding: 4px 6px;
      border-radius: 6px;
      transition: background 0.2s, color 0.2s;
    }
    #hud-small-panel .hud-section-nav a:hover {
      color: #5B9CFF !important;  /* same hover color as links panel */
      background: rgba(91,156,255,0.08);
    }
    #hud-small-panel button {
      padding: 10px;
      font-size: 14px;
      font-weight: 500;
      color: #9AA6B2;
      background: rgba(18, 23, 34, 0.50);
      backdrop-filter: blur(2px) saturate(140%);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    
    /* Desktop: vertical layout */
    #hud-small-panel button {
      width: 100%;
    }
    
    /* Mobile: horizontal layout */
    @media (max-width: 479px) {
      #hud-small-panel {
        flex-direction: row !important;
        flex-wrap: wrap;
      }
      #hud-small-panel button {
        width: auto !important;
        flex: 1 1 auto !important;
        min-width: 0;
      }
    }
    #hud-small-panel button:hover {
      color: #5B9CFF;
      background: rgba(91, 156, 255, 0.08);
    }
    #hud-small-panel button.active-tab {
      color: #CFE8FF;
      background: rgba(91,156,255,0.12);
      border-color: #5B9CFF;
      box-shadow: 0 0 0 1px rgba(91,156,255,0.25) inset;
    }

    /* === Custom header, tagline and links panel for the portfolio site === */
    header#site-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2000;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 6px 14px;
      background: var(--panel-ghost);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(20px) saturate(160%);
      font-family: inherit;
    }
    /* Keep blur effect in HUD mode (reduced intensity for performance) */
    .hud-active header#site-header {
      backdrop-filter: blur(20px) saturate(160%);
      background: rgba(18,23,34,0.50);
    }
    .header-logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header-logo .name {
      font-weight: 600;
      font-size: 18px;
      letter-spacing: 0.2px;
      color: #CFE8FF;
      white-space: nowrap;
    }
    .header-logo .tagline {
      margin-left: 12px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 400;
      white-space: nowrap;
    }
    .header-spacer { flex: 1; }
    .header-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px !important; /* unify size across viewports */
      height: 36px; /* fixed visual height */
      line-height: 1;
      box-sizing: border-box;
      font-size: 14px;
      font-weight: 500;
      color: var(--muted);
      background: transparent;
      border: 1px solid transparent; /* stabilize size on hover */
      border-radius: 0;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .header-btn:hover {
      color: var(--accent);
      background: rgba(91, 156, 255, 0.08);
    }
    .header-btn:active {
      color: #4A8AE6;
      background: rgba(91, 156, 255, 0.15);
    }
    /* Normalize theme toggle container children to button size */
    #theme-toggle-container { display: flex; align-items: center; gap: 8px; }
    /* Normalize all header controls to identical size and states */
    #theme-toggle-container > * {
      width: 44px; height: 44px; padding: 10px;
      border-radius: 0 !important;
      display: inline-flex; align-items: center; justify-content: center;
      box-sizing: border-box;
      background: transparent; color: var(--muted);
      border: 1px solid transparent; cursor: pointer;
      line-height: 1; gap: 0;
    }
    /* Hover/active match header buttons */
    #theme-toggle-container > *:hover { color: var(--accent); background: rgba(91,156,255,0.08); }
    #theme-toggle-container > *:active { color: #4A8AE6; background: rgba(91,156,255,0.15); }
    /* Icon sizes and color unification */
    #theme-toggle-container img, #tour-restart-btn img { width: 24px; height: 24px; display: block; }
    #theme-toggle-container svg, #tour-restart-btn svg { width: 24px; height: 24px; }
    /* Project gray color for icons */
    :root { --icon-gray: #9AA6B2; }
    #theme-toggle-container svg { fill: var(--icon-gray) !important; stroke: var(--icon-gray) !important; }
    #tour-restart-btn img { filter: brightness(0) saturate(100%) invert(73%) sepia(5%) saturate(342%) hue-rotate(176deg) brightness(92%) contrast(89%); }
    /* Hover: accent tint, matches buttons */
    #theme-toggle-container > *:hover svg { fill: #5B9CFF !important; stroke: #5B9CFF !important; }
    #tour-restart-btn:hover img { filter: brightness(0) saturate(100%) invert(66%) sepia(58%) saturate(618%) hue-rotate(186deg) brightness(101%) contrast(101%); }
    /* === Custom header, tagline and links panel for the portfolio site === */
    /* Header styling improvements for the HUD */
    #hud-small-panel .hud-section-header {
      position: relative;
      padding: 12px;
      background: rgba(18,23,34,0.35);
      backdrop-filter: blur(2px) saturate(140%);
      border: 1px solid #243041;
      border-radius: 8px;
    }
    #hud-small-panel .hud-section-title {
      margin: 0 0 4px 0;
      
      font-weight: 400;
      color: #CFE8FF;
    }
    #hud-small-panel .hud-section-summary {
      margin: 10px 0 18px 0;  /* increased top and bottom margins by 10px */
      
      line-height: 1.4;
      color: var(--muted);
    }
    #hud-small-panel .hud-section-nav {
      display: flex;
      gap: 8px;
      justify-content: flex-start;
    }
    #hud-small-panel .hud-section-nav a {
      flex: 1 1 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      font-size: 16px;
      font-weight: 200 !important;
      color: #9AA6B2 !important;  /* same color as links panel */
      background: rgba(18, 23, 34, 0.80);
      border: 1px solid #243041;
      border-radius: 6px;
      text-decoration: none;
      transition: background 0.2s, color 0.2s, border-color 0.2s;
      cursor: pointer;
      pointer-events: auto; /* Ensure links receive clicks */
      touch-action: manipulation; /* Enable touch on mobile */
    }
    #hud-small-panel .hud-section-nav a:hover {
      color: #5B9CFF !important;  /* same hover color as links panel */
      background: rgba(91,156,255,0.08);
      border-color: #5B9CFF;
    }
    /* Close button styling for the header */
    #hud-small-panel .hud-close-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 6px;
      font-size: 16px;
      font-weight: 600;
      color: #9AA6B2 !important;  /* same color as links panel */
      background: rgba(18, 23, 34, 0.80);
      border: 1px solid #243041;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, border-color 0.2s;

      /* Ensure the close button remains a small icon rather than stretching like the tab buttons. */
      width: auto !important;
      height: auto !important;
      flex: 0 0 auto;
    }
    #hud-small-panel .hud-close-btn:hover {
      color: #5B9CFF !important;  /* same hover color as links panel */
      background: rgba(91,156,255,0.08);
      border-color: #5B9CFF;
    }

    /* Responsive layout for tablet screens: stack panels vertically */
    @media (max-width: 767px) {
      #hud-container {
        top: 120px;
        flex-direction: column;
        gap: 16px;
        width: 90%;
        overflow-y: auto;              /* tablet: scroll container */
      }
      #hud-container #hud-small-panel {
        width: 100%;
      }
      #hud-container #hud-big-panel { width: 100%; }
      #hud-small-panel .hud-section-title {
        font-size: 18px;
      }
      #hud-small-panel .hud-section-summary {
        font-size: 16px;
      }
      #hud-small-panel button {
        font-size: 15px;
      }
    }

    /* Responsive layout for mobile screens: further increase text sizes and
       allow the big panel to use more vertical space */
    @media (max-width: 479px) {
      #hud-container {
        top: 72px;
        width: 94%;
      }
      #hud-small-panel .hud-section-title {
        font-size: 20px;
      }
      #hud-small-panel .hud-section-summary {
        font-size: 16px;
      }
      #hud-small-panel .hud-section-nav a {
        font-size: 16px !important;  /* same size as main text */
      }
    }
    /* Removed floating tagline; tagline now integrated with header logo */
    #links-panel {
      position: fixed;
      top: 90px;
      right: 20px;
      width: 420px; /* desktop: larger than before */
      z-index: 1850;
      display: none;
      flex-direction: column;
      gap: 13px; /* line spacing increased by 5px */
      padding: 12px 12px 10px 12px;
      /* Container stays transparent; items style themselves */
      background: none;
      border: none;
      border-radius: 12px;
    }
    /* Mobile: full width and centered */
    @media (max-width: 767px) {
      #links-panel {
        left: 20px;
        right: 20px;
        transform: none;
        width: auto;
        max-width: none;
        top: 72px;
      }
    }
    .link-row a {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      text-decoration: none;
      font-size: 16px !important;  /* same size as main text */
      font-weight: 400;
      /* Override inherited colour from body with !important to ensure the muted tone */
      color: var(--muted) !important;
      background: transparent;
      border: none;
      border-radius: 8px;
      transition: background 0.2s, color 0.2s;
    }
    .link-row a:hover {
      color: var(--accent) !important;
      background: rgba(91, 156, 255, 0.08);
    }
    .link-kicker {
      font-size: 12px;
      color: #9AA6B2;
      opacity: 0.75;
      padding: 0 12px; /* align with link rows */
      margin-top: 10px; /* shift down by 10px */
    }

    /* Close button for links panel */
    #links-panel .close-btn {
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 18px;
      color: #9AA6B2;
      background: none;
      border: none;
      cursor: pointer;
      transition: color 0.2s;
    }
    #links-panel .close-btn:hover {
      color: #CFE8FF;
    }
    /* Ensure HUD buttons look slightly bolder: we already set weight via main
       declaration. This override is removed to avoid conflicting with the
       unified button styles. */
    /* Removed redundant HUD weight override */

    /* Orbit mode banner */
    #mode-banner {
      position: fixed;
      top: 75px; /* 56px + 19px = 75px */
      left: 50%;
      transform: translateX(-50%);
      z-index: 2100;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 600;
      color: #CFE8FF;
      background: rgba(18,23,34,0.80);
      border: 1px solid var(--border);
      border-radius: 10px;
      backdrop-filter: blur(8px);
      display: none;
      pointer-events: none;
    }
    /* In HUD mode, banner should be below overlay (z-index 900) and hud-backdrop (z-index 940) */
    .hud-active #mode-banner {
      z-index: 800 !important;
    }
    /* Hide orbit banner on mobile */
    @media (max-width: 767px) {
      #mode-banner { display: none !important; }
    }
    /* Also remove blur on big HUD panels during HUD activity */
    .hud-active #hud-big-panel,
    .hud-active #hud-container #hud-big-panel {
      backdrop-filter: none !important;
    }
    /* HUD mode: square corners everywhere */
    .hud-active #hud-container,
    .hud-active #hud-container *,
    .hud-active #hud-small-panel,
    .hud-active #hud-small-panel *,
    .hud-active #hud-big-panel,
    .hud-active #hud-big-panel *,
    .hud-active .hud,
    .hud-active .hud * {
      border-radius: 0 !important;
    }
    /* Remove borders from all elements globally */
    body * { border: none !important; }
    /* In HUD mode render grid canvas below header and text panels, but above overlay */
    .hud-active #grid-canvas { z-index: 950 !important; pointer-events: none; }
    /* In Links mode raise grid above links overlay backdrop but below the panel content */
    .links-active #grid-canvas { z-index: 1845 !important; pointer-events: none; }
    /* Background grid under HUD overlay */
    #grid-canvas-bg { position: fixed; inset: 0; pointer-events: none; z-index: 890; }
    /* On mobile, keep same layering as desktop: base lines above overlay */
    @media (max-width: 767px) {
      .hud-active #grid-canvas { z-index: 950 !important; }
      .links-active #grid-canvas { z-index: 1845 !important; }
      body.tour-active #grid-canvas { z-index: 2490 !important; }
      #grid-canvas-bg { z-index: 880; }
      /* Ensure panels remain above base lines */
      .hud-active #hud-container,
      .hud-active #hud-big-panel,
      .hud-active #hud-small-panel { z-index: 1000 !important; }
      .links-active #links-panel { z-index: 1850 !important; }
    }

    /* Force square corners globally across states */
    button,
    button:hover,
    button:active,
    button:focus,
    .header-btn,
    .header-btn:hover,
    .header-btn:active,
    .header-btn:focus,
    a,
    a:hover,
    a:active,
    a:visited,
    input,
    input:hover,
    input:focus,
    select,
    select:hover,
    select:focus,
    textarea,
    textarea:hover,
    textarea:focus,
    .btn,
    .btn:hover,
    .btn:active,
    .btn:focus,
    .chip,
    .chip:hover,
    .chip:active,
    .chip:focus,
    .panel,
    .panel:hover,
    .panel:active,
    .panel:focus,
    .card,
    .card:hover,
    .card:active,
    .card:focus,
    #links-panel .link-row a,
    #links-panel .link-row a:hover,
    #links-panel .link-row a:active,
    #links-panel .link-row a:visited,
    #links-panel .close-btn,
    #links-panel .close-btn:hover,
    #links-panel .close-btn:active,
    #links-panel .close-btn:focus {
      border-radius: 0 !important;
    }
    /* During tour, grid should be visible through the card */
    /* Grid is below card but visible through transparent card background */
    body.tour-active #grid-canvas { z-index: 2490 !important; pointer-events: none; }
    /* Default browser cursors in use */
    .hud-active button,
    .hud-active a,
    .hud-active input,
    .hud-active select,
    .hud-active textarea,
    .hud-active .chip,
    .hud-active .label,
    .hud-active .link-row a,
    .hud-active .btn,
    .hud-active .panel,
    .hud-active .card {
      border-radius: 0 !important;
    }

    

    
    /* HUD mode: square corners everywhere */
    .hud-active #hud-container,
    .hud-active #hud-container *,
    .hud-active #hud-small-panel,
    .hud-active #hud-small-panel *,
    .hud-active #hud-big-panel,
    .hud-active #hud-big-panel *,
    .hud-active .hud,
    .hud-active .hud * {
      border-radius: 0 !important;
    }
    .hud-active button,
    .hud-active a,
    .hud-active input,
    .hud-active select,
    .hud-active textarea,
    .hud-active .chip,
    .hud-active .label,
    .hud-active .link-row a,
    .hud-active .btn,
    .hud-active .panel,
    .hud-active .card {
      border-radius: 0 !important;
    }
    /* Disable page scroll when HUD is active */
    /* On mobile, allow container scroll but prevent body scroll */
    body.hud-active,
    html.hud-active {
      overflow: hidden !important;
      height: 100% !important;
      position: fixed !important;
      width: 100% !important;
    }
    /* On mobile/tablet, allow HUD container to scroll */
    @media (max-width: 767px) {
      body.hud-active,
      html.hud-active {
        position: fixed !important;
        overflow: hidden !important;
      }
      #hud-container {
        -webkit-overflow-scrolling: touch !important;
        overscroll-behavior: contain !important;
      }
    }
  
/* === Strict overrides: no borders on HUD controls; mobile containment === */
#hud-small-panel .hud-section-nav a,
#hud-small-panel .hud-close-btn {
  border: none !important;
  background: transparent !important;
  box-shadow: none !important;
}
#hud-small-panel .hud-section-nav a:hover,
#hud-small-panel .hud-close-btn:hover {
  border: none !important;
  background: rgba(91,156,255,0.08) !important;
  color: #CFE8FF !important;
}
/* Big panel: contain within viewport; avoid horizontal overflow */
/* REMOVED to restore fixed desktop layout; container/mobile rules remain */
/*
#hud-big-panel {
  width: 100%;
  max-width: 100vw;
  height: auto;
  max-height: calc(100dvh - 260px);
  overflow-y: auto;
  overflow-x: hidden;
  box-sizing: border-box;
  overflow-wrap: anywhere;
  word-break: break-word;
}
*/
/* When big panel is inside the responsive container */
/*
#hud-container #hud-big-panel {
  width: 100%;
  max-width: 100vw;
  height: auto;
  max-height: calc(100dvh - 260px);
  overflow-y: auto;
  overflow-x: hidden;
  box-sizing: border-box;
  overflow-wrap: anywhere;
  word-break: break-word;
}
*/
/* Tablet */
@media (max-width: 767px) {
  /* removed duplicate - using mobile styles from line 740 */
}
/* Mobile */
@media (max-width: 479px) {
  /* Show orbit toggle on mobile */
  #mobile-orbit-toggle {
    display: flex !important;
  }
}


/* === Patch: keep Prev/Next on one line === */
#hud-small-panel .hud-section-nav {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: nowrap; /* do not wrap to second line */
}
#hud-small-panel .hud-section-nav a {
  flex: 0 0 auto !important;   /* don't stretch, don't wrap */
  white-space: nowrap !important;
  padding: 2px 6px !important;  /* tighter to fit in one row */
  font-weight: 200 !important;
  line-height: 1.1 !important;
}
/* Ensure link in big panel has same weight as main text */
#hud-big-panel .hud-tab-link {
  font-weight: 200 !important;
  color: #9AA6B2 !important;  /* same color as links panel */
}
#hud-big-panel .hud-tab-link:hover {
  color: #5B9CFF !important;  /* same hover color as links panel */
}
/* Style links in solution text */
#hud-big-panel a[target="_blank"]:not(.hud-tab-link) {
  color: #9AA6B2 !important;  /* same color as links panel */
  text-decoration: none;
  font-weight: 200 !important;
  font-size: inherit !important;  /* same size as main text */
  border-bottom: 1px solid rgba(154,166,178,0.3);
  transition: border-color 0.2s, color 0.2s;
}
#hud-big-panel a[target="_blank"]:not(.hud-tab-link):hover {
  color: #5B9CFF !important;  /* same hover color as links panel */
  border-bottom-color: rgba(91,156,255,0.8);
}

/* Mobile orbit mode toggle */
#mobile-orbit-toggle {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 900;
  display: flex;
}

#toggle-orbit-btn {
  background: rgba(18, 23, 34, 0.85);
      border: 1px solid var(--border);
  border-radius: 10px;
  padding: 8px 14px;
      color: var(--text);
  font-size: 14px;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 0 0 1px rgba(36,48,65,0.4) inset, 0 2px 10px rgba(0,0,0,0.25);
  white-space: nowrap;
  opacity: 0.96;
}

#toggle-orbit-btn:hover {
  background: rgba(36, 48, 65, 0.95);
  border-color: #5B9CFF;
  color: #CFE8FF;
}

#toggle-orbit-btn.active {
  background: rgba(91, 156, 255, 0.15);
  border-color: #5B9CFF;
  color: #5B9CFF;
}

#toggle-orbit-btn.active:hover {
  border-color: #4A8AE6;
  color: #CFE8FF;
}

#toggle-orbit-icon {
  width: 24px;
  height: 24px;
  display: block;
  filter: brightness(0) saturate(100%) invert(65%) sepia(8%) saturate(443%) hue-rotate(177deg) brightness(94%) contrast(92%);
  transition: filter 200ms ease;
}

/* Active orbit mode: tint icon to accent blue */
#toggle-orbit-btn.active #toggle-orbit-icon {
  filter: brightness(0) saturate(100%) invert(42%) sepia(66%) saturate(1675%) hue-rotate(189deg) brightness(101%) contrast(98%);
}

/* Disable smooth scroll globally */
html {
  scroll-behavior: auto;
}

/* === Mobile: scroll the HUD container instead of the big panel to guarantee bottom visibility === */
@media (max-width: 479px) {
  #hud-container {
    top: 72px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 94% !important;
    height: auto !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    padding-bottom: 24px !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain !important;
    /* hide scrollbar on mobile */
    scrollbar-width: none;
  }
  #hud-container::-webkit-scrollbar { width: 0; height: 0; }
  #hud-container #hud-big-panel {
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
    padding-bottom: 40px !important;
  }
  /* Увеличиваем крестик закрытия на мобильных */
  #hud-small-panel .hud-close-btn {
    font-size: 22px !important;
    padding: 6px 8px !important;
    min-width: 36px !important;
    min-height: 36px !important;
  }
}

/* Ultra-narrow safeguard */
@media (max-width: 360px) {
  #hud-small-panel .hud-section-nav a {
    font-size: 16px !important;
    font-weight: 200 !important;
    padding: 2px 4px !important;
  }
}


@media (max-width: 479px) {
  #btn-demo { display: none !important; }
}


/* Mobile header: hide logo, left-align 'Автор' and 'Ссылки' */
@media (max-width: 479px) {
  header#site-header { justify-content: flex-start !important; gap: 8px !important; }
  header#site-header .header-logo { display: none !important; }
  header#site-header .header-spacer { display: none !important; }
  #btn-demo { display: none !important; }
  .header-btn { padding: 8px 12px !important; height: 36px; }
}


/* Mobile: show 'Смотреть демо' and keep buttons left-aligned */
@media (max-width: 479px) {
  #btn-demo { display: inline-flex !important; }
  header#site-header { justify-content: flex-start !important; gap: 8px !important; }
  .header-btn { padding: 8px 12px !important; height: 36px; }
}


/* === HUD title font refinement === */
#hud-small-panel .hud-section-title {
  font-weight: 400 !important;  /* same weight as labels for consistency */
  font-size: 15px !important;
  letter-spacing: 0.2px;
}
#hud-small-panel .hud-section-summary {
  font-weight: 400 !important;
  font-size: 16px !important;
  color: #A5B4C3 !important;
}


/* === Tablet: mirror mobile behavior (container scroll, tail always reachable) === */
@media (max-width: 767px) {
  #hud-container {
    top: 72px !important;
    bottom: 12px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 94% !important;
    height: auto !important;
    max-height: none !important;
    overflow-y: auto !important;          /* scroll on container */
    overflow-x: hidden !important;
    padding-bottom: 24px !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain !important;
    /* hide scrollbar on tablet */
    scrollbar-width: none;
  }
  #hud-container::-webkit-scrollbar { width: 0; height: 0; }
  #hud-container #hud-big-panel {
    width: 100% !important;
    max-width: 100vw !important;
    height: auto !important;
    max-height: none !important;          /* let it grow; container handles scroll */
    overflow: visible !important;
    padding-bottom: 16px !important;      /* ensure last line/link is not cut */
    box-sizing: border-box !important;
    overflow-wrap: anywhere !important;
    word-break: break-word !important;
  }
  /* Keep Prev/Next in one row on tablet too */
  #hud-small-panel .hud-section-nav {
    flex-wrap: nowrap !important;
  }
  #hud-small-panel .hud-section-nav a {
    flex: 0 0 auto !important;
    white-space: nowrap !important;
    padding: 4px 8px !important;
    line-height: 1.4 !important;
    font-size: 16px !important;  /* Единый размер с мобильной версией */
    font-weight: 200 !important;
  }
}

/* Размер шрифта кнопок навигации для мобильных (переопределяет планшетный стиль) */
@media (max-width: 479px) {
  #hud-small-panel .hud-section-nav a {
    font-size: 16px !important;
    font-weight: 200 !important;
    padding: 4px 8px !important;
    white-space: nowrap !important;
    flex: 0 0 auto !important;
    line-height: 1.4 !important;
  }
}


/* === Tablet header: show only logo (no tagline) and buttons === */
@media (min-width: 480px) and (max-width: 767px) {
  header#site-header { justify-content: space-between !important; gap: 12px !important; }
  header#site-header .header-logo { display: flex !important; align-items: center !important; }
  header#site-header .header-logo .tagline { display: none !important; } /* убрать подзаголовок */
  /* Кнопки в одну строку, компактные отступы */
  .header-btn { padding: 8px 12px !important; height: 36px; }
  #btn-demo { display: inline-flex !important; } /* демо остаётся видимой */
}


/* === Unified thin dark scrollbars (mobile-like) === */
html, body { scrollbar-gutter: stable; }

/* Firefox */
html, body,
#overlay {
  scrollbar-width: thin;
  scrollbar-color: #3B4A5F transparent;
}
#hud-big-panel {
  scrollbar-width: none;
  scrollbar-color: transparent transparent;
}

/* Chromium/WebKit */
html::-webkit-scrollbar,
body::-webkit-scrollbar,
#overlay::-webkit-scrollbar { width: 8px; height: 8px; }
#hud-big-panel::-webkit-scrollbar { width: 0px; height: 0px; display: none; }

html::-webkit-scrollbar-track,
body::-webkit-scrollbar-track,
#overlay::-webkit-scrollbar-track { background: transparent; }
#hud-big-panel::-webkit-scrollbar-track { background: transparent; display: none; }

html::-webkit-scrollbar-thumb,
body::-webkit-scrollbar-thumb,
#overlay::-webkit-scrollbar-thumb {
  background: rgba(59, 74, 95, 0.9);
  border-radius: 8px;
  border: 2px solid transparent;
  background-clip: padding-box;
}
#hud-big-panel::-webkit-scrollbar-thumb {
  display: none;
}

#overlay:hover::-webkit-scrollbar-thumb,
#hud-big-panel:hover::-webkit-scrollbar-thumb,
html:hover::-webkit-scrollbar-thumb,
body:hover::-webkit-scrollbar-thumb {
  background: rgba(59, 74, 95, 1);
}

/* === HUD Grid hologram effect === */
.grid-line {
  pointer-events: none;
  /* dashed via repeating gradient; color set via --c */
  --c: var(--grid-color, rgba(92, 182, 255, 0.18));
  --dash: 10px;   /* length of visible segment */
  --gap: 8px;     /* length of gap */
  --phase: 0px;   /* starting offset */
  background: none;
  box-shadow:
    0 0 3px rgba(92, 182, 255, 0.22),
    0 0 8px rgba(92, 182, 255, 0.14);
  mix-blend-mode: screen;
  opacity: var(--grid-opacity, 0.85);
  filter: hue-rotate(var(--grid-hue, 0deg)) saturate(var(--grid-sat, 1.1));
  will-change: opacity, filter, transform, background-position;
}
.grid-line::after {
  content: '';
  position: absolute; inset: 0;
  pointer-events: none;
}
.grid-line.h { /* horizontal dashed */
  background-image: repeating-linear-gradient(
    90deg,
    var(--c) 0 calc(var(--dash)),
    rgba(255,255,255,0) calc(var(--dash)) calc(calc(var(--dash) + var(--gap)))
  );
  background-size: calc(var(--dash) + var(--gap)) 100%;
  background-position: var(--phase, 0px) 0;
}
.grid-line.h::after {
  /* горизонтальная линия: лёгкий бегущий блик */
  background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(200,240,255,0.35) 50%, rgba(255,255,255,0) 100%);
  background-size: 220% 100%;
  background-position: var(--shimmerH, 0%) 0;
}
.grid-line.v { /* vertical dashed */
  background-image: repeating-linear-gradient(
    180deg,
    var(--c) 0 calc(var(--dash)),
    rgba(255,255,255,0) calc(var(--dash)) calc(calc(var(--dash) + var(--gap)))
  );
  background-size: 100% calc(var(--dash) + var(--gap));
  background-position: 0 var(--phase, 0px);
}
.grid-line.v::after {
  /* вертикальная линия: блик сверху вниз */
  background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(200,240,255,0.35) 50%, rgba(255,255,255,0) 100%);
  background-size: 100% 220%;
  background-position: 0 var(--shimmerV, 0%);
}
/* Убраны CSS-анимации; значения управляются из движка через CSS-переменные */

/* Final override: hide container scrollbar on mobile/tablet (Chromium/WebKit + Firefox) */
@media (max-width: 767px) {
  #hud-container { scrollbar-width: none !important; }
  #hud-container::-webkit-scrollbar { width: 0 !important; height: 0 !important; }
  #hud-container::-webkit-scrollbar-thumb { background: transparent !important; }
  #hud-container { scrollbar-gutter: auto; }
}


/* remove stray flex override; container visibility controlled above */

/* === Header buttons default spacing via .header-spacer (override removed) === */

/* (Reset rules are defined once above; duplicates removed) */

  /* === HUD spacing normalization: equal top padding in headers and big panel === */
  #hud-small-panel .hud-section-header { padding: 16px 12px 12px 12px; }
  #hud-big-panel, #hud-container #hud-big-panel { padding-top: 16px; }
  #hud-big-panel > :first-child, #hud-container #hud-big-panel > :first-child { margin-top: 0 !important; }

  /* === Tour restart icon next to theme toggle === */
  #tour-restart-btn { display:inline-flex; align-items:center; justify-content:center; width: 44px; height: 44px; margin-left: 6px; border:1px solid var(--border); border-radius: 10px; background: transparent; color: #9AA6B2; cursor: pointer; transition: background .2s, color .2s, border-color .2s; }
  #tour-restart-btn:hover { background: rgba(36,48,65,0.95); color:#CFE8FF; border-color:#5B9CFF; }
  #tour-restart-btn:active { color:#CFE8FF; border-color:#4A8AE6; }
  #tour-restart-btn:focus { outline: 2px solid #5B9CFF; outline-offset: 2px; }
  #tour-restart-btn .icon { font-size: 18px; line-height: 1; }

</style>
</head>
<body>

<!-- Preloader overlay -->
<div id="preloader-overlay" aria-hidden="true">
  <iframe id="preloader-frame" src="./ux4ai-preloader-loop-outline-noise.html" title="UX4AI Preloader" loading="eager"></iframe>
  <style>
    #preloader-overlay {
      position: fixed; inset: 0; z-index: 3000;
      background: #0B0F14; /* match theme bg to avoid flash */
      display: flex; align-items: center; justify-content: center;
    }
    #preloader-overlay.hidden { display: none !important; }
    #preloader-frame { width: 100%; height: 100%; border: 0; }
  </style>
</div>

<!-- Guided Tour Overlay (A/B/C) -->
<div id="tour-overlay" aria-hidden="true" class="hidden">
  <div class="tour-backdrop"></div>
  <div class="tour-card" role="dialog" aria-modal="true" aria-labelledby="tour-title" aria-describedby="tour-text">
    <div class="tour-header">
      <h2 id="tour-title"></h2>
      <p class="tour-sub" id="tour-sub"></p>
    </div>
    <div class="tour-body">
      <p id="tour-text"></p>
    </div>
    <div class="tour-interactives" id="tour-interactives" aria-hidden="true">
      <noscript>
        <div class="tour-interactives-fallback">
          <p style="color: #9AA6B2; font: 400 14px/1.3 ui-sans-serif, system-ui; text-align: center; margin: 0;">
            Интерактивные элементы требуют JavaScript
          </p>
        </div>
      </noscript>
    </div>
    <div class="tour-actions" id="tour-actions"></div>
    <div class="tour-frame-lines" aria-hidden="true"></div>
  </div>
  <style>
    #tour-overlay { position: fixed; inset: 0; z-index: 2500; display: flex; align-items: center; justify-content: center; }
    #tour-overlay.hidden { display: none !important; }
    #tour-overlay .tour-backdrop { position:absolute; inset:0; background: rgba(5,8,12,0.60); backdrop-filter: blur(2px) saturate(120%); z-index: 1; }
    /* HUD-like styling: straight corners; no inner grid - grid visible through card */
    #tour-overlay .tour-card { position: relative; width: min(720px, 92vw);
      background: rgba(18,23,34,0.35);
      backdrop-filter: blur(2px) saturate(140%);
      border:1px solid #243041; border-radius: 0; box-shadow: 0 12px 40px rgba(0,0,0,0.45); padding: 20px 20px 20px 20px; color:#E6EEF8; z-index: 2; }
    /* Disable per-card grid to keep through-grid effect like HUD */
    #tour-overlay .tour-frame-lines { display:none; }
    /* Close link inside actions */
    #tour-overlay .tour-actions .close-link { 
      background: transparent; border: none; color:#9AA6B2; text-decoration: none; 
      padding: 10px 14px; height: 44px; display:inline-flex; align-items:center; justify-content:center;
      font: 400 18px/1 ui-sans-serif, system-ui; box-sizing: border-box;
      opacity: 0.5;
    }
    #tour-overlay .tour-actions .close-link:hover { color:#CFE8FF; opacity: 1; }
    @media (min-width: 480px) {
      #tour-overlay .tour-actions .close-link { margin-left: auto; }
    }
    #tour-overlay .tour-header h2 { margin: 0 0 32px 0; font: 600 24px/1.3 ui-sans-serif, system-ui; color:#CFE8FF; white-space: pre-line; }
    #tour-overlay .tour-header .tour-sub { margin: 0 0 32px 0; color:#9AA6B2; font: 400 18px/1.3 ui-sans-serif, system-ui; }
    /* Reduce sub margin when followed by links list (step 2) */
    #tour-overlay .tour-card.tour-step-2 .tour-header .tour-sub { margin-bottom: 8px !important; }
    /* Ensure consistent spacing: sub → content (16px), content → buttons (32px) */
    #tour-overlay .tour-body { margin-top: 0; }
    #tour-overlay .tour-body p { margin: 0 0 32px 0; color:#B8C3CF; font: 300 18px/1.3 ui-sans-serif, system-ui; }
    /* Icon color matching text color - use mask to inherit text color */
    #tour-overlay .tour-body p img { 
      filter: brightness(0) saturate(100%) invert(72%) sepia(2%) saturate(1000%) hue-rotate(180deg);
    }
    /* Tour case links styled like HUD "contacts" links */
    #tour-overlay .tour-body .tour-list { 
      margin: 0 0 px 0; 
      padding: 0; 
      list-style: none; 
      display: flex; 
      flex-direction: column; 
      gap: 0; 
      align-items: flex-start; 
    }
    /* When list is inside p, remove p's margin and let list handle spacing */
    #tour-overlay .tour-body p:has(.tour-list) { margin: 0; }
    #tour-overlay .tour-body .tour-list li { margin: 0; line-height: 1; }
    #tour-overlay .tour-body .tour-list a {
      display: flex; 
      align-items: center;
      gap: 8px;
      text-decoration: none; 
      font: 400 18px/1 ui-sans-serif, system-ui;
      color: #9AA6B2 !important; 
      background: transparent; 
      border: none; 
      border-radius: 0;
      transition: color 0.2s, background 0.2s;
    }
    /* Icon color matching link text color */
    #tour-overlay .tour-body .tour-list a img {
      filter: brightness(0) saturate(100%) invert(65%) sepia(5%) saturate(500%) hue-rotate(180deg);
      transition: filter 0.2s;
    }
    #tour-overlay .tour-body .tour-list a:hover { 
      color: #5B9CFF !important; 
      background: rgba(91,156,255,0.08); 
    }
    /* Icon color on hover - match accent color */
    #tour-overlay .tour-body .tour-list a:hover img {
      filter: brightness(0) saturate(100%) invert(60%) sepia(100%) saturate(2000%) hue-rotate(200deg);
    }
    #tour-overlay .tour-body .tour-list a:visited { color: #9AA6B2 !important; }
    #tour-overlay .tour-body .tour-list a:visited:hover { color: #5B9CFF !important; }
    #tour-overlay .tour-actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 0; }
    #tour-overlay .tour-actions .btn { padding: 10px 14px; border-radius: 0; border:1px solid #243041; background: rgba(18,23,34,0.9); color:#9AA6B2; font: 400 18px/1 ui-sans-serif, system-ui; text-decoration: none; cursor: pointer; transition: background .2s, color .2s, border-color .2s; display:inline-flex; align-items:center; justify-content:center; height: 44px; box-sizing: border-box; }
    #tour-overlay .tour-actions .btn:hover { background: rgba(36,48,65,0.95); color:#CFE8FF; border-color:#5B9CFF; }
    #tour-overlay .tour-actions .btn-primary { color:#CFE8FF; background: rgba(91,156,255,0.12); border-color:#5B9CFF; }
    #tour-overlay .tour-actions .btn-primary:hover { background: rgba(91,156,255,0.18); }
    @media (max-width: 479px) {
      #tour-overlay { align-items: flex-start; padding-top: 20px; padding-bottom: 40px; }
      /* Card fills the viewport height with 20px top and 40px bottom gutters; buttons at bottom */
      #tour-overlay .tour-card {
        padding: 16px;
        margin-left: auto; margin-right: auto;
        display: flex; flex-direction: column;
        width: calc(100vw - 40px);
        min-height: calc(100dvh - 60px);
        max-height: calc(100dvh - 60px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      #tour-overlay .tour-body { flex: 1 1 auto; }
      #tour-overlay .tour-actions { flex-direction: column; margin-top: auto; }
      #tour-overlay .tour-actions .btn { width: 100%; text-align: center; }
    }
    /* Block page scroll when tour is active, but allow scrolling inside tour card */
    body.tour-active,
    html.tour-active {
      overflow: hidden !important;
      height: 100% !important;
      position: fixed !important;
      width: 100% !important;
    }
    /* Allow scrolling inside tour card */
    #tour-overlay .tour-card {
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(100vh - 40px);
    }
    @media (max-width: 479px) {
      #tour-overlay .tour-card {
        max-height: calc(100dvh - 60px);
      }
    }
    
    /* Tour Interactives Styles */
    #tour-overlay .tour-interactives {
      margin-top: 32px;
      margin-bottom: 40px;
    }
    
    #tour-overlay .tour-interactives.loaded {
      opacity: 1;
    }
    
    /* Skeleton loaders */
    #tour-overlay .tour-interactives-skeleton {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    #tour-overlay .skeleton-header,
    #tour-overlay .skeleton-status {
      height: 24px;
      background: rgba(36, 48, 65, 0.5);
      border-radius: 0;
      animation: skeleton-pulse 1.5s ease-in-out infinite;
    }
    
    #tour-overlay .skeleton-header {
      width: 60%;
    }
    
    #tour-overlay .skeleton-status {
      width: 80%;
      height: 16px;
    }
    
    #tour-overlay .skeleton-interactives {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }
    
    #tour-overlay .skeleton-item {
      height: 200px;
      background: rgba(36, 48, 65, 0.5);
      border-radius: 0;
      animation: skeleton-pulse 1.5s ease-in-out infinite;
    }
    
    #tour-overlay .skeleton-cta {
      height: 44px;
      width: 60%;
      margin: 0 auto;
      background: rgba(36, 48, 65, 0.5);
      border-radius: 0;
      animation: skeleton-pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes skeleton-pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.8; }
    }
    
    #tour-overlay .tour-interactives-wrapper {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    
    /* Section header */
    #tour-overlay .tour-interactives-header {
      margin: 0 0 20px 0;
      font: 600 20px/1.3 ui-sans-serif, system-ui;
      color: #CFE8FF;
    }
    
    /* Status bar */
    #tour-overlay .tour-status-bar {
      padding: 8px 0;
      font: 400 14px/1.3 ui-sans-serif, system-ui;
      color: #9AA6B2;
      border-bottom: 1px solid #243041;
    }
    
    /* Interactives layout - single column */
    
    #tour-overlay .tour-interactive {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    /* Interactive A - left aligned, vertical layout */
    #tour-overlay .tour-interactive-a {
      align-items: flex-start !important;
      display: flex !important;
      flex-direction: column !important;
      flex-wrap: nowrap !important;
    }
    
    /* Thermometer widget container */
    #tour-overlay .thermometer-widget-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
    }
    
    /* Thermometer widget header */
    #tour-overlay .thermometer-widget-header {
      margin: 0 0 12px 0;
      font: 600 24px/1.3 ui-sans-serif, system-ui;
      color: #CFE8FF;
      text-align: left;
      width: 100%;
      flex-shrink: 0;
      display: block;
    }
    
    /* Thermometer widget description */
    #tour-overlay .thermometer-widget-description {
      margin: 0 0 32px 0;
      font: 300 18px/1.3 ui-sans-serif, system-ui;
      color: #B8C3CF;
      text-align: left;
      width: 100%;
      flex-shrink: 0;
    }
    
    /* Thermometer container */
    #tour-overlay .thermometer-container {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: flex-start;
      width: 100%;
      flex-shrink: 0;
    }
    
    /* Override gap between segments and user feeling text */
    #tour-overlay .thermometer-segments-container + .thermometer-user-feeling {
      margin-top: -12px;
    }
    
    #tour-overlay .thermometer-container:focus {
      outline: 2px solid #5B9CFF;
      outline-offset: 2px;
    }
    
    /* Placeholder (top right corner) */
    #tour-overlay .readout-placeholder {
      position: absolute;
      top: 0;
      right: 0;
      max-width: 300px;
      width: 300px;
      font: 300 18px/1.3 ui-sans-serif, system-ui;
      color: #B8C3CF;
      transition: color 0.3s ease;
      text-align: right;
      word-wrap: break-word;
      white-space: pre-line;
    }
    
    /* Readout (above buttons, left-aligned) */
    #tour-overlay .thermometer-readout {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-start;
      width: 100%;
    }
    
    #tour-overlay .readout-value {
      font: 600 56px/1 ui-sans-serif, system-ui;
      color: #CFE8FF;
      transition: color 0.3s ease;
    }
    
    #tour-overlay .readout-status {
      font: 400 14px/1.3 ui-sans-serif, system-ui;
      color: #9AA6B2;
      transition: color 0.3s ease;
    }
    
    /* User feeling text (under buttons) */
    #tour-overlay .thermometer-user-feeling {
      margin: 4px 0 0 0;
      font: 300 18px/1.3 ui-sans-serif, system-ui;
      color: #B8C3CF;
      text-align: left;
      width: 100%;
    }
    
    /* Segments container (horizontal row) */
    #tour-overlay .thermometer-segments-container {
      display: flex;
      flex-direction: row;
      gap: 8px;
      flex-wrap: nowrap;
      width: 100%;
    }
    
    /* Thermometer segments */
    #tour-overlay .thermometer-segment {
      flex: 1;
      min-width: 0;
      padding: 12px 8px;
      background: rgba(36, 48, 65, 0.6);
      border: 1px solid #243041;
      color: #9AA6B2;
      font: 400 14px/1 ui-sans-serif, system-ui;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Default zone colors (dim) */
    #tour-overlay .thermometer-segment.zone-1 {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.3);
    }
    
    #tour-overlay .thermometer-segment.zone-2 {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.3);
    }
    
    #tour-overlay .thermometer-segment.zone-3 {
      background: rgba(234, 179, 8, 0.08);
      border-color: rgba(234, 179, 8, 0.3);
    }
    
    #tour-overlay .thermometer-segment.zone-4 {
      background: rgba(234, 179, 8, 0.08);
      border-color: rgba(234, 179, 8, 0.3);
    }
    
    #tour-overlay .thermometer-segment.zone-5 {
      background: rgba(239, 68, 68, 0.08);
      border-color: rgba(239, 68, 68, 0.3);
    }
    
    #tour-overlay .thermometer-segment:hover {
      opacity: 0.8;
      transform: translateY(-1px);
    }
    
    #tour-overlay .thermometer-segment:focus {
      outline: 2px solid #5B9CFF;
      outline-offset: 2px;
    }
    
    /* Active state (bright colors) */
    #tour-overlay .thermometer-segment.active {
      color: #CFE8FF;
      font-weight: 600;
      opacity: 1;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    #tour-overlay .thermometer-segment.zone-1.active {
      background: rgba(34, 197, 94, 0.25);
      border-color: #22C55E;
    }
    
    #tour-overlay .thermometer-segment.zone-2.active {
      background: rgba(34, 197, 94, 0.25);
      border-color: #22C55E;
    }
    
    #tour-overlay .thermometer-segment.zone-3.active {
      background: rgba(234, 179, 8, 0.25);
      border-color: #EAB308;
    }
    
    #tour-overlay .thermometer-segment.zone-4.active {
      background: rgba(234, 179, 8, 0.25);
      border-color: #EAB308;
    }
    
    #tour-overlay .thermometer-segment.zone-5.active {
      background: rgba(239, 68, 68, 0.25);
      border-color: #EF4444;
    }
    
    
    /* CTA Container */
    #tour-overlay .tour-cta-container {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    #tour-overlay .tour-cta-btn {
      flex: 1;
      min-width: 0;
      padding: 12px 8px;
      background: rgba(91, 156, 255, 0.12);
      border: 1px solid #5B9CFF;
      color: #CFE8FF;
      font: 400 14px/1 ui-sans-serif, system-ui;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    #tour-overlay .tour-cta-btn:hover {
      background: rgba(91, 156, 255, 0.18);
      border-color: #7BB3FF;
    }
    
    #tour-overlay .tour-cta-btn:focus {
      outline: 2px solid #5B9CFF;
      outline-offset: 2px;
    }
    
    #tour-overlay .tour-cta-subtext {
      margin: 0;
      color: #9AA6B2;
      font: 300 12px/1.3 ui-sans-serif, system-ui;
      text-align: center;
    }
    
    /* Desktop and Tablet styles (>=768px) */
    @media (min-width: 768px) {
      #tour-overlay .thermometer-widget-description {
        max-width: 100%;
      }
      
      #tour-overlay .thermometer-container {
        max-width: 100%;
      }
      
      #tour-overlay .thermometer-segments-container {
        max-width: 100%;
      }
      
      #tour-overlay .thermometer-user-feeling {
        max-width: 100%;
      }
      
      #tour-overlay .readout-value {
        font-size: 61px;
      }
      
      #tour-overlay .readout-status {
        font-size: 19px;
      }
      
      #tour-overlay .readout-placeholder {
        font-size: 18px;
        max-width: 400px;
        width: auto;
      }
    }
    
    /* Mobile Responsive */
    @media (max-width: 767px) {
      
      #tour-overlay .thermometer-widget-header {
        font-size: 20px;
      }
      
      #tour-overlay .readout-value {
        font-size: 42px;
      }
      
      #tour-overlay .readout-placeholder {
        font-size: 14px;
      }
      
      #tour-overlay .thermometer-segments-container {
        max-width: 352px;
      }
      
      #tour-overlay .skeleton-interactives {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 479px) {
      #tour-overlay .tour-cta-btn {
        width: 100%;
      }
    }
    
    /* Light theme support */
    .theme-light #tour-overlay .skeleton-header,
    .theme-light #tour-overlay .skeleton-status,
    .theme-light #tour-overlay .skeleton-item,
    .theme-light #tour-overlay .skeleton-cta {
      background: rgba(226, 232, 240, 0.5);
    }
    
    .theme-light #tour-overlay .tour-interactives-header {
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .tour-status-bar {
      color: #64748B;
      border-bottom-color: #E2E8F0;
    }
    
    .theme-light #tour-overlay .thermometer-widget-header {
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .thermometer-widget-description {
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .thermometer-segment {
      background: rgba(241, 245, 249, 0.6);
      border-color: #E2E8F0;
      color: #64748B;
    }
    
    /* Default zone colors for light theme (dim) */
    .theme-light #tour-overlay .thermometer-segment.zone-1 {
      background: rgba(34, 197, 94, 0.1);
      border-color: rgba(34, 197, 94, 0.4);
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-2 {
      background: rgba(34, 197, 94, 0.1);
      border-color: rgba(34, 197, 94, 0.4);
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-3 {
      background: rgba(234, 179, 8, 0.1);
      border-color: rgba(234, 179, 8, 0.4);
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-4 {
      background: rgba(234, 179, 8, 0.1);
      border-color: rgba(234, 179, 8, 0.4);
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-5 {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.4);
    }
    
    .theme-light #tour-overlay .thermometer-segment:hover {
      opacity: 0.8;
    }
    
    .theme-light #tour-overlay .thermometer-segment.active {
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-1.active {
      background: rgba(34, 197, 94, 0.3);
      border-color: #22C55E;
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-2.active {
      background: rgba(34, 197, 94, 0.3);
      border-color: #22C55E;
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-3.active {
      background: rgba(234, 179, 8, 0.3);
      border-color: #EAB308;
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-4.active {
      background: rgba(234, 179, 8, 0.3);
      border-color: #EAB308;
    }
    
    .theme-light #tour-overlay .thermometer-segment.zone-5.active {
      background: rgba(239, 68, 68, 0.3);
      border-color: #EF4444;
    }
    
    .theme-light #tour-overlay .readout-value {
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .readout-placeholder {
      color: #64748B;
    }
    
    .theme-light #tour-overlay .readout-example {
      color: #64748B;
    }
    
    .theme-light #tour-overlay .thermometer-user-feeling {
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .readout-status {
      color: #64748B;
    }
    
    .theme-light #tour-overlay .tour-cta-subtext {
      color: #64748B;
    }
    
    .theme-light #tour-overlay .tour-cta-btn {
      background: rgba(59, 130, 246, 0.12);
      border-color: #3B82F6;
      color: #0F172A;
    }
    
    .theme-light #tour-overlay .tour-cta-btn:hover {
      background: rgba(59, 130, 246, 0.18);
    }
    
    /* HUD big panel headings - tour style (highest priority, at end of CSS) */
    #hud-big-panel h1,
    #hud-big-panel h2,
    #hud-big-panel h3,
    #hud-big-panel h4,
    #hud-big-panel h5,
    #hud-big-panel h6,
    .hud-active #hud-big-panel h1,
    .hud-active #hud-big-panel h2,
    .hud-active #hud-big-panel h3,
    .hud-active #hud-big-panel h4,
    .hud-active #hud-big-panel h5,
    .hud-active #hud-big-panel h6,
    #hud-container #hud-big-panel h1,
    #hud-container #hud-big-panel h2,
    #hud-container #hud-big-panel h3,
    #hud-container #hud-big-panel h4,
    #hud-container #hud-big-panel h5,
    #hud-container #hud-big-panel h6,
    .hud-active #hud-container #hud-big-panel h1,
    .hud-active #hud-container #hud-big-panel h2,
    .hud-active #hud-container #hud-big-panel h3,
    .hud-active #hud-container #hud-big-panel h4,
    .hud-active #hud-container #hud-big-panel h5,
    .hud-active #hud-container #hud-big-panel h6 {
      font: 600 20px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
      white-space: normal !important;
    }
    /* Main heading (h2) - 10px margin bottom to paragraph (highest priority) */
    #hud-big-panel h2,
    .hud-active #hud-big-panel h2,
    #hud-container #hud-big-panel h2,
    .hud-active #hud-container #hud-big-panel h2 {
      margin: 0 0 10px 0 !important;
    }
    /* Subheadings (h3, h4) - smaller than main heading (highest priority) */
    #hud-big-panel h3,
    .hud-active #hud-big-panel h3,
    #hud-container #hud-big-panel h3,
    .hud-active #hud-container #hud-big-panel h3 {
      font: 600 18px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
      white-space: normal !important;
    }
    #hud-big-panel h4,
    .hud-active #hud-big-panel h4,
    #hud-container #hud-big-panel h4,
    .hud-active #hud-container #hud-big-panel h4 {
      font: 600 16px/1.3 ui-sans-serif, system-ui !important;
      color: #CFE8FF !important;
      margin: 0 0 0 0 !important;
      font-weight: 600 !important;
      white-space: normal !important;
    }
    /* Paragraph spacing: 20px between paragraphs (highest priority) */
    #hud-big-panel p,
    .hud-active #hud-big-panel p,
    #hud-container #hud-big-panel p,
    .hud-active #hud-container #hud-big-panel p {
      margin: 0 0 20px 0 !important;
      line-height: 1.5 !important;
    }
    #hud-big-panel p:last-child,
    .hud-active #hud-big-panel p:last-child,
    #hud-container #hud-big-panel p:last-child,
    .hud-active #hud-container #hud-big-panel p:last-child {
      margin-bottom: 0 !important;  /* Убрать отступ у последнего абзаца */
    }
    /* Remove spacing after subheadings - no margin for first paragraph after h3/h4 (highest priority) */
    #hud-big-panel h3 + p,
    #hud-big-panel h4 + p,
    .hud-active #hud-big-panel h3 + p,
    .hud-active #hud-big-panel h4 + p,
    #hud-container #hud-big-panel h3 + p,
    #hud-container #hud-big-panel h4 + p,
    .hud-active #hud-container #hud-big-panel h3 + p,
    .hud-active #hud-container #hud-big-panel h4 + p {
      margin-top: 0 !important;  /* Убрать отступ у первого абзаца после подзаголовка */
    }
  </style>
</div>

<!-- Header -->
<header id="site-header">
  <div class="header-logo">
    <span class="name">Владимир Костял</span>
    <span class="tagline">проектирую UX архитектуру и интерфейсы для AI сервисов</span>
  </div>
  <div class="header-spacer"></div>
  <button class="header-btn" id="btn-demo">Демо</button>
  <button class="header-btn" id="btn-links">Ссылки</button>
  <button class="header-btn" id="btn-about">Автор</button>
  <div id="theme-toggle-container"></div>
  <select id="theme-select" style="display:none;">
    <option value="calm">Calm</option>
    <option value="matrix">Matrix</option>
  </select>
</header>

<!-- Mode banner -->
<div id="mode-banner">Режим: Орбита (ESC — вернуться к пролистыванию)</div>

<!-- Mobile orbit mode toggle -->
<div id="mobile-orbit-toggle" style="display: none;">
  <button id="toggle-orbit-btn">
    <img id="toggle-orbit-icon" src="./camera_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="Camera" />
  </button>
</div>

<!-- Links panel -->
<div id="links-panel">
  <button class="close-btn" id="btn-links-close">✕</button>
  <div class="link-row"><a href="#" id="lnk-tg-chat" target="_blank">💬 Написать в Telegram</a></div>
  <div class="link-row"><a href="#" id="lnk-tg-community" target="_blank">👥 Перейти в сообщество</a></div>
  <div class="link-row"><a href="#" id="lnk-resume" target="_blank">📄 Резюме (PDF)</a></div>
  <div class="link-kicker">Все контакты открываются в новой вкладке.</div>
</div>

<!-- Canvas and labels -->
<div id="three-container"></div>
<div id="labels"></div>

<!-- HUD elements -->
<div id="overlay"></div>
<!-- HUD backdrop (similar to tour backdrop) -->
<div id="hud-backdrop" class="hidden"></div>

<div id="hud-object-icon"></div>
<!-- Wrap the HUD panels inside a container so they can be centred and stacked responsively -->
<div id="hud-container">
  <div id="hud-small-panel">
    <button data-index="0">Вариант 1</button>
    <button data-index="1">Вариант 2</button>
    <button data-index="2">Вариант 3</button>
          </div>
  <div id="hud-big-panel"></div>
        </div>

  <!-- Grid overlay (thin through-borders that form the HUD grid) -->
  <div id="grid-overlay" aria-hidden="true"></div>
  <!-- Background grid under HUD overlay -->
  <canvas id="grid-canvas-bg" aria-hidden="true"></canvas>
  <canvas id="grid-canvas" aria-hidden="true"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/"
  }
}
</script>
<script type="module">
async function init() {
  try {
    console.log('[Bootstrap] Importing THREE via importmap...');
    const THREE = await import('three');
    console.log('✓ THREE imported');
    // Try hiding preloader as soon as core deps are ready
    try { const pre = document.getElementById('preloader-overlay'); if (pre) pre.classList.add('hidden'); } catch {}
    
    // Make available globally for modules
    window.THREE = THREE;
    
    console.log('[Bootstrap] Importing modules...');
    const { createEngine } = await import('./core/engine.js?v=37');
    const { initThemeSwitcher } = await import('./ui/themeSwitcher.js?v=37');
    const { initHUD } = await import('./core/hud-manager.js?v=46');
    
    console.log('[Bootstrap] Creating engine...');
    const engine = createEngine({
      canvasParent: document.getElementById('three-container'),
      labelsElement: document.getElementById('labels')
    });
    // Hide preloader once engine is created (early UX)
    try { const pre = document.getElementById('preloader-overlay'); if (pre) pre.classList.add('hidden'); } catch {}
    // Expose engine for grid overlay to query current scene state
    try { window._engine = engine; } catch(_) {}
    
    console.log('[Bootstrap] Initializing theme switcher...');
    initThemeSwitcher(engine);
    // Inject Tour Restart icon next to theme toggle
    try {
      const container = document.getElementById('theme-toggle-container') || document.getElementById('site-header');
      if (container) {
        let btn = document.getElementById('tour-restart-btn');
        if (!btn) {
          btn = document.createElement('button');
          btn.id = 'tour-restart-btn';
          btn.className = 'header-btn';
          btn.setAttribute('aria-label', 'Перезапустить тур');
          btn.title = 'Перезапустить тур';
          btn.tabIndex = 0;
          btn.innerHTML = '<img src="./replay_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="Restart tour" width="24" height="24" aria-hidden="true" />';
          container.appendChild(btn);
        }
        const canShowTourRestartIcon = () => {
          try {
            const overlayActive = !!(document.getElementById('tour-overlay') && !document.getElementById('tour-overlay').classList.contains('hidden'));
            return !overlayActive; // always available across scenes
          } catch { return true; }
        };
        const updateVisibility = () => { btn.style.display = canShowTourRestartIcon() ? 'inline-flex' : 'none'; };
        updateVisibility();
        window.addEventListener('hashchange', updateVisibility);
        window.addEventListener('storage', updateVisibility);
        document.addEventListener('readystatechange', updateVisibility);
        // Analytics: view when in viewport
        try {
          const io = new IntersectionObserver((entries)=>{
            entries.forEach(en=>{ if (en.isIntersecting) { console.log('analytics: tour_restart_icon_view'); io.disconnect(); } });
          });
          io.observe(btn);
        } catch {}
        const tour_reset = () => {
          try { 
            localStorage.removeItem('tour_done'); 
            localStorage.setItem('tour_step','1'); 
          } catch {}
          // Use window.tour_reset if available (properly resets to step 1)
          if (typeof window.tour_reset === 'function') {
            window.tour_reset();
            return;
          }
          // Fallback: try to set step manually using window.setTourStep
          try {
            const overlay = document.getElementById('tour-overlay');
            if (overlay) {
              overlay.classList.remove('hidden'); 
              overlay.setAttribute('aria-hidden','false');
              // Try to set step to 1 using exported function
              if (typeof window.setTourStep === 'function') {
                window.setTourStep(1);
              } else {
                // Last resort: reload page to ensure clean start
                location.reload();
              }
            }
          } catch (e) {
            console.warn('[Tour] Error resetting tour:', e);
            // Last resort: reload page
            try { location.reload(); } catch {}
          }
        };
        const onActivate = (e) => {
          if (e.type === 'keydown' && !(e.key === 'Enter' || e.key === ' ')) return;
          const overlayActive = !!(document.getElementById('tour-overlay') && !document.getElementById('tour-overlay').classList.contains('hidden'));
          if (overlayActive) return; // ignore when tour is already open
          console.log('analytics: tour_restart_click');
          tour_reset();
          updateVisibility();
          e.preventDefault();
        };
        btn.addEventListener('click', onActivate);
        btn.addEventListener('keydown', onActivate);
        // Self-healing: if theme switcher re-renders, re-insert the button
        try {
          const ensureBtn = () => {
            let b = document.getElementById('tour-restart-btn');
            if (!b) {
              b = document.createElement('button');
              b.id = 'tour-restart-btn';
              b.className = 'header-btn';
              b.setAttribute('aria-label', 'Перезапустить тур');
              b.title = 'Перезапустить тур';
              b.tabIndex = 0;
              b.innerHTML = '<img src="./replay_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="Restart tour" width="24" height="24" aria-hidden="true" />';
              container.appendChild(b);
              b.addEventListener('click', onActivate);
              b.addEventListener('keydown', onActivate);
              updateVisibility();
            }
          };
          const mo = new MutationObserver(() => ensureBtn());
          mo.observe(container, { childList: true, subtree: true });
        } catch {}
      }
    } catch {}
    
    // Listen for theme mounted event and then initialize HUD
    let hud = null;
    engine.on('themeMounted', () => {
      if (!hud) {
        hud = initHUD({
          overlay: document.getElementById('overlay'),
          hudObjectIcon: document.getElementById('hud-object-icon'),
          hudBigPanel: document.getElementById('hud-big-panel'),
          hudSmallPanel: document.getElementById('hud-small-panel'),
          hudContainer: document.getElementById('hud-container'),
          labelsLayer: document.getElementById('labels'),
          btnAbout: document.getElementById('btn-about'),
          btnLinks: document.getElementById('btn-links'),
          btnDemo: document.getElementById('btn-demo'),
          linksPanel: document.getElementById('links-panel'),
          btnLinksClose: document.getElementById('btn-links-close')
        });
      }
      // Hide preloader when the first theme fully mounts
      try {
        const pre = document.getElementById('preloader-overlay');
        if (pre) setTimeout(() => pre.classList.add('hidden'), 150);
      } catch {}
    });
    
    console.log('[Bootstrap] ✅ Ready!');
    // Safety: hide preloader on load even if themeMounted didn't fire (fallback)
    window.addEventListener('load', () => {
      try {
        const pre = document.getElementById('preloader-overlay');
        if (pre) pre.classList.add('hidden');
      } catch {}
    }, { once: true });
    // Absolute safety: hide regardless after a maximum wait
    setTimeout(() => {
      try { const pre = document.getElementById('preloader-overlay'); if (pre) pre.classList.add('hidden'); } catch {}
    }, 8000);

    // ===== Guided Tour (A->B->C) =====
    (function initGuidedTour(){
      const params = new URLSearchParams(location.search);
      if (params.get('tour') === 'off') return;
      if (params.get('tour') === 'reset') {
        try { localStorage.removeItem('tour_done'); localStorage.removeItem('tour_step'); } catch {}
      }
      const done = (typeof localStorage !== 'undefined') ? localStorage.getItem('tour_done') : null;
      if (done === '1') return;
      const overlay = document.getElementById('tour-overlay');
      if (!overlay) return;
      const titleEl = document.getElementById('tour-title');
      const subEl = document.getElementById('tour-sub');
      const textEl = document.getElementById('tour-text');
      const actionsEl = document.getElementById('tour-actions');
      const interactivesEl = document.getElementById('tour-interactives');

      const steps = {
        1: {
          title: `Владимир Костял. UX-архитектор. 
          Проектировщик интерфейсов для AI-продуктов`,
          sub: 'Проектирую понятные и масштабируемые UX-паттерны для ассистентов, агентных систем и внутренних платформ. Прозрачность ИИ, контроль стоимости и продуктивность команд — в одном дизайне.',
          text: `<span style="display: inline-flex; align-items: center; gap: 8px;"><img src="./supervisor_account_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="" width="20" height="20" />  Управляю продуктом и кросс-функциональными командами.</span> <br>
<span style="display: inline-flex; align-items: center; gap: 8px;"><img src="./graph_2_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="" width="20" height="20" />  Собираю дизайн-системы и шаблоны для быстрого выхода в прод и роста.</span> <br>
<span style="display: inline-flex; align-items: center; gap: 8px;"><img src="./monitoring_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="" width="20" height="20" />  Настраиваю метрики и дашборды (TTFT↓, cost/request↓, ошибки↓, CSAT/конверсия↑)</span>`,
          actions: [
            { type:'button', primary:true, label:'Кейсы', on:'next' },
            { type:'link', label:'Резюме', href:'./Vladimir_Kostyal_Resume.pdf' },
            { type:'link', label:'UX4AI (PDF гайд + ссылки)', href:'https://t.me/...' }
          ]
        },
        2: {
          title: 'Контролируемый AI вместо «чёрного ящика»',
          sub: 'Оркестрация ассистентов и агентов в одном интерфейсе: прозрачные решения, управляемые данные, безопасность и метрики. Рабочая система: роли и сценарии, права и бюджеты, единая панель контроля. Управление рисками: где хранятся данные, срок жизни, маскировка PII, аудит событий.',
          text: '<ul class="tour-list">\n<li><a href="#" target="_blank"><img src="./call_made_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="" width="18" height="18" /> Почему так? — Live Answer Trace (Figma demo)</a></li>\n<li><a href="#" target="_blank"><img src="./call_made_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="" width="18" height="18" /> Orchestrator Dashboard (Figma demo)</a></li>\n<li><a href="#" target="_blank"><img src="./call_made_24dp_434343_FILL0_wght400_GRAD0_opsz24.svg" alt="" width="18" height="18" /> Scenario Builder / Playbooks (Figma demo)</a></li>\n</ul>',
          actions: [
            { type:'button', primary:false, label:'Назад', on:'back' },
            { type:'button', primary:true, label:'Далее', on:'next' },
            { type:'link', label:'Написать в TG', href:'https://t.me/scrumux' }
          ]
        },
        3: {
          title: 'От знакомства к исследованиям',
          sub: 'Люди решают за 6–10 секунд — заголовок, первая строка и наличие аргументов (исследование eye-tracking, F/Z-паттерны, «информационный запах»).',
          text: 'Если верить исследованию, первых 2 экранов должно было хватить  для принятия решения. Если нет... ну что же, это не единственная точка входа, а метрики дадут точную картину. . Далее углубляемся непосредственно в тему UX для AI. Разбираемся в проблемах и исследуем решения ;)',
          actions: [
            { type:'button', primary:false, label:'Назад', on:'back' },
            { type:'button', primary:true, label:'К обзору', on:'finish' },
            { type:'link', label:'Написать в TG', href:'https://t.me/scrumux' }
          ]
        }
      };

      // Initialize tour interactives for step 3
      function initTourInteractives(container) {
        container.innerHTML = '';
        container.setAttribute('aria-hidden', 'false');
        
        // Create skeleton loaders first
        const skeleton = document.createElement('div');
        skeleton.className = 'tour-interactives-skeleton';
        skeleton.innerHTML = `
          <div class="skeleton-header"></div>
          <div class="skeleton-status"></div>
          <div class="skeleton-interactives">
            <div class="skeleton-item"></div>
            <div class="skeleton-item"></div>
          </div>
          <div class="skeleton-cta"></div>
        `;
        container.appendChild(skeleton);
        
        // Create wrapper for interactives
        const wrapper = document.createElement('div');
        wrapper.className = 'tour-interactives-wrapper';
        wrapper.style.display = 'none';
        
        // Section header
        const sectionHeader = document.createElement('h3');
        sectionHeader.className = 'tour-interactives-header';
        sectionHeader.textContent = 'С чего стоит начать оптимизировать AI-продукт';
        
        wrapper.appendChild(sectionHeader);
        
        // Interactive A: TTFT → Trust Thermometer
        const interactiveA = document.createElement('div');
        interactiveA.className = 'tour-interactive tour-interactive-a';
        interactiveA.setAttribute('role', 'group');
        interactiveA.setAttribute('aria-label', 'TTFT к доверию');
        
        // Widget container (header + description + widget)
        const widgetContainer = document.createElement('div');
        widgetContainer.className = 'thermometer-widget-container';
        
        // Description text (replaces header)
        const widgetDescription = document.createElement('p');
        widgetDescription.className = 'thermometer-widget-description';
        widgetDescription.textContent = 'TTFT формирует доверие. Проверьте сколько времени тратит пользователь продукта на ожидание появления первого токена ответа от модели на экране. Эта одна из основных метрик, которая формирует % удержания пользователей.';
        
        // Thermometer container
        const thermometerContainer = document.createElement('div');
        thermometerContainer.className = 'thermometer-container';
        thermometerContainer.setAttribute('role', 'group');
        thermometerContainer.setAttribute('aria-label', 'Термометр времени ответа');
        thermometerContainer.setAttribute('tabindex', '0');
        
        // Readout value (above buttons, left-aligned)
        const readout = document.createElement('div');
        readout.className = 'thermometer-readout';
        readout.setAttribute('aria-live', 'polite');
        readout.setAttribute('aria-atomic', 'true');
        
        const readoutValue = document.createElement('div');
        readoutValue.className = 'readout-value';
        readoutValue.textContent = '95';
        
        const readoutStatus = document.createElement('div');
        readoutStatus.className = 'readout-status';
        readoutStatus.textContent = '% удержания';
        
        readout.appendChild(readoutValue);
        readout.appendChild(readoutStatus);
        
        // Placeholder (top right corner of widget)
        const readoutPlaceholder = document.createElement('div');
        readoutPlaceholder.className = 'readout-placeholder';
        readoutPlaceholder.textContent = '⚡ «Мгновенный контакт»\nПоток сохранён. \nЭто зона "живого отклика".';
        
        // Segments container (horizontal row)
        const segmentsContainer = document.createElement('div');
        segmentsContainer.className = 'thermometer-segments-container';
        
        // Create 5 clickable segments
        const segments = [
          { ttft: 1, label: '≤1s', zone: 'zone-1' },
          { ttft: 2, label: '2s', zone: 'zone-2' },
          { ttft: 3, label: '3s', zone: 'zone-3' },
          { ttft: 5, label: '5s', zone: 'zone-4' },
          { ttft: 7, label: '≥7s', zone: 'zone-5' }
        ];
        
        segments.forEach((seg, index) => {
          const segment = document.createElement('button');
          segment.type = 'button';
          segment.className = `thermometer-segment ${seg.zone}`;
          segment.setAttribute('role', 'option');
          segment.setAttribute('aria-selected', 'false');
          segment.setAttribute('data-ttft', seg.ttft);
          segment.setAttribute('aria-label', `Время ответа ${seg.label}`);
          segment.textContent = seg.label;
          segmentsContainer.appendChild(segment);
        });
        
        thermometerContainer.appendChild(readoutPlaceholder);
        thermometerContainer.appendChild(readout);
        thermometerContainer.appendChild(segmentsContainer);
        
        // User feeling text (under buttons)
        const userFeelingEl = document.createElement('p');
        userFeelingEl.className = 'thermometer-user-feeling';
        userFeelingEl.textContent = 'Взгляд пользователя в фокусе. Есть ощущение совместной работы. Диалог течёт без паузы.';
        thermometerContainer.appendChild(userFeelingEl);
        
        widgetContainer.appendChild(widgetDescription);
        widgetContainer.appendChild(thermometerContainer);
        interactiveA.appendChild(widgetContainer);
        
        wrapper.appendChild(interactiveA);
        container.appendChild(wrapper);
        
        // Initialize interactions
        initThermometerInteraction(thermometerContainer, readoutValue, readoutStatus, readoutPlaceholder, userFeelingEl);
        
        // Lazy load: observe when container enters viewport
        if ('IntersectionObserver' in window) {
          const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                // Hide skeleton, show content
                skeleton.style.display = 'none';
                wrapper.style.display = 'block';
                container.classList.add('loaded');
                // Track view metric
                trackMetric('metric_view', { section: 'tour_card_3' });
                observer.unobserve(entry.target);
              }
            });
          }, { rootMargin: '50px', threshold: 0.1 });
          observer.observe(container);
        } else {
          // Fallback: load immediately
          skeleton.style.display = 'none';
          wrapper.style.display = 'block';
          container.classList.add('loaded');
        }
      }
      
      // Thermometer interaction handler
      function initThermometerInteraction(container, readoutValue, readoutStatus, readoutPlaceholder, userFeelingEl) {
        const segments = container.querySelectorAll('.thermometer-segment');
        let activeIndex = 0; // Start with first segment (≤1s)
        
        // Data from table
        const widgetData = {
          1: {
            retention: 88,
            displayScore: 95,
            metaphor: '⚡ «Мгновенный контакт»',
            userFeeling: 'Пользователь в фокусе. Есть ощущение совместной работы. Диалог течёт без паузы.',
            uxMeaning: 'Поток сохранён. \nЭто зона "живого отклика".'
          },
          2: {
            retention: 76,
            displayScore: 76,
            metaphor: '👁️ «Внимание ещё здесь»',
            userFeeling: 'Пользователь замечает лёгкую паузу, но ждёт — доверие остаётся.',
            uxMeaning: 'Комфортный UX. \nМозг всё ещё "в диалоге".'
          },
          3: {
            retention: 63,
            displayScore: 63,
            metaphor: '💭 «Начинает отвлекаться»',
            userFeeling: 'Мысль успевает ускользнуть: человек ждёт, но уже смотрит в сторону, доверие падает.',
            uxMeaning: 'Риск потери потока. \nНадо показать, что ответ формируется.'
          },
          5: {
            retention: 40,
            displayScore: 40,
            metaphor: '⏳ «Сомнение»',
            userFeeling: 'Половина пользователей решают — система зависла; ощущение контроля почти исчезает.',
            uxMeaning: 'Критическая зона. \nНужны визуальные признаки активности.'
          },
          7: {
            retention: 16,
            displayScore: 16,
            metaphor: '❌ «Потеря контакта»',
            userFeeling: 'Пользователь уходит мысленно или физически. Сессия воспринимается как сбой.',
            uxMeaning: 'UX-провал. \nПотеря доверия и вовлечённости.'
          }
        };
        
        function updateThermometer(ttft) {
          const data = widgetData[ttft] || widgetData[1];
          
          // Update readout
          readoutValue.textContent = data.displayScore;
          readoutStatus.textContent = '% удержания';
          
          // Update placeholder with metaphor + UX meaning
          readoutPlaceholder.textContent = `${data.metaphor}\n${data.uxMeaning}`;
          
          // Update user feeling text under buttons
          if (userFeelingEl) {
            userFeelingEl.textContent = data.userFeeling;
          }
          
          // Update active segment
          segments.forEach((seg, index) => {
            const isActive = parseInt(seg.dataset.ttft) === ttft;
            seg.classList.toggle('active', isActive);
            seg.setAttribute('aria-selected', isActive ? 'true' : 'false');
            if (isActive) {
              activeIndex = index;
            }
          });
          
          // Track metric
          trackMetric('metric_interact', { 
            widget: 'ttft', 
            valueSec: ttft, 
            trustScore: data.displayScore 
          });
        }
        
        // Click handler for segments
        segments.forEach(segment => {
          segment.addEventListener('click', () => {
            const ttft = parseInt(segment.dataset.ttft);
            updateThermometer(ttft);
          });
        });
        
        // Keyboard support (arrow keys on container)
        container.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (activeIndex > 0) {
              const prevSegment = segments[activeIndex - 1];
              const ttft = parseInt(prevSegment.dataset.ttft);
              updateThermometer(ttft);
              prevSegment.focus();
            }
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (activeIndex < segments.length - 1) {
              const nextSegment = segments[activeIndex + 1];
              const ttft = parseInt(nextSegment.dataset.ttft);
              updateThermometer(ttft);
              nextSegment.focus();
            }
          } else if (e.key === 'Home') {
            e.preventDefault();
            const firstSegment = segments[0];
            const ttft = parseInt(firstSegment.dataset.ttft);
            updateThermometer(ttft);
            firstSegment.focus();
          } else if (e.key === 'End') {
            e.preventDefault();
            const lastSegment = segments[segments.length - 1];
            const ttft = parseInt(lastSegment.dataset.ttft);
            updateThermometer(ttft);
            lastSegment.focus();
          }
        });
        
        // Initialize with first segment
        updateThermometer(1);
      }
      
      // CTA download handler
      function initCTADownload(button) {
        button.addEventListener('click', (e) => {
          trackMetric('metric_download_plan', { file: 'UX4AI_90day_plan.pdf' });
          // Default behavior (download) will handle the rest
        });
      }
      
      // Analytics/metrics tracking
      function trackMetric(name, data) {
        if (typeof window.analytics !== 'undefined' && typeof window.analytics.track === 'function') {
          window.analytics.track(name, data);
        } else {
          console.info(`[Analytics] ${name}:`, data);
        }
      }
      
      // allow only <br> in text; escape everything else; also support \n -> <br>
      function sanitizeAllowBr(str){
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\n/g, '<br>')
          .replace(/&lt;br\s*\/?&gt;/gi, '<br>')
          // allow very limited HTML for links list (normalize UL to have class)
          .replace(/&lt;ul(?:\s+class=\"tour-list\")?\s*&gt;/gi, '<ul class="tour-list">')
          .replace(/&lt;\/ul&gt;/gi, '</ul>')
          .replace(/&lt;li&gt;/gi, '<li>')
          .replace(/&lt;\/li&gt;/gi, '</li>')
          // allow span and img tags for icons (before processing links, so img inside links works)
          .replace(/&lt;span([^&]*)&gt;/gi, '<span$1>')
          .replace(/&lt;\/span&gt;/gi, '</span>')
          .replace(/&lt;img\s+([^&]*?)(?:\s*\/)?&gt;/gi, '<img $1>')
          .replace(/&lt;a\s+href=\"([^\"]*)\"(?:\s+target=\"[^\"]*\")?\s*&gt;/gi, '<a href="$1" target="_blank">')
          .replace(/&lt;\/a&gt;/gi, '</a>');
      }

      function setStep(step){
        const s = steps[step]; if (!s) return;
        try { localStorage.setItem('tour_step', String(step)); } catch {}
        // Add class to card for step 2 (with links list) to reduce spacing
        const card = document.querySelector('.tour-card');
        if (card) {
          if (step === 2) {
            card.classList.add('tour-step-2');
          } else {
            card.classList.remove('tour-step-2');
          }
        }
        titleEl.textContent = s.title;
        subEl.textContent = s.sub;
        textEl.innerHTML = sanitizeAllowBr(s.text);
        actionsEl.innerHTML = '';
        // Clear and hide interactives by default
        if (interactivesEl) {
          interactivesEl.innerHTML = '';
          interactivesEl.setAttribute('aria-hidden', 'true');
          interactivesEl.classList.remove('loaded');
        }
        s.actions.forEach(a => {
          if (a.type === 'link') {
            const link = document.createElement('a');
            link.className = 'btn';
            link.href = a.href; 
            const isPdf = a.href.toLowerCase().endsWith('.pdf');
            // For PDF files: open in new tab and also trigger download
            if (isPdf) {
              link.target = '_blank';
              link.addEventListener('click', (e) => {
                // Open in new tab (default behavior)
                // Also trigger download
                setTimeout(() => {
                  const downloadLink = document.createElement('a');
                  downloadLink.href = a.href;
                  downloadLink.download = a.href.split('/').pop() || 'download.pdf';
                  downloadLink.style.display = 'none';
                  document.body.appendChild(downloadLink);
                  downloadLink.click();
                  document.body.removeChild(downloadLink);
                }, 100);
              });
            } else {
              link.target = a.href.startsWith('http') ? '_blank' : '_self';
            }
            link.textContent = a.label;
            actionsEl.appendChild(link);
          } else {
            const btn = document.createElement('button');
            btn.type = 'button'; btn.className = 'btn' + (a.primary ? ' btn-primary' : '');
            btn.textContent = a.label;
            if (a.on === 'next') btn.addEventListener('click', () => setStep(Math.min(3, step+1)));
            if (a.on === 'back') btn.addEventListener('click', () => setStep(Math.max(1, step-1)));
            if (a.on === 'finish') btn.addEventListener('click', finishTour);
            actionsEl.appendChild(btn);
          }
        });
        // Add "План оптимизации" button for step 3, after all actions but before close
        if (step === 3) {
          const planButton = document.createElement('a');
          planButton.href = '/assets/UX4AI_90day_plan.pdf';
          planButton.className = 'btn';
          planButton.setAttribute('download', 'UX4AI_90day_plan.pdf');
          planButton.setAttribute('aria-label', 'Скачать план оптимизации');
          planButton.textContent = 'План оптимизации';
          // Handle PDF download
          planButton.target = '_blank';
          planButton.addEventListener('click', (e) => {
            setTimeout(() => {
              const downloadLink = document.createElement('a');
              downloadLink.href = '/assets/UX4AI_90day_plan.pdf';
              downloadLink.download = 'UX4AI_90day_plan.pdf';
              downloadLink.style.display = 'none';
              document.body.appendChild(downloadLink);
              downloadLink.click();
              document.body.removeChild(downloadLink);
            }, 100);
            trackMetric('metric_download_plan', { file: 'UX4AI_90day_plan.pdf' });
          });
          actionsEl.appendChild(planButton);
        }
        // add close link as last action
        const closeA = document.createElement('a');
        closeA.href = '#';
        closeA.className = 'close-link';
        closeA.textContent = 'Закрыть';
        closeA.addEventListener('click', (e)=>{ e.preventDefault(); dismissTour(); });
        actionsEl.appendChild(closeA);
        
        // Add interactives for step 3
        if (step === 3 && interactivesEl) {
          initTourInteractives(interactivesEl);
        }
        
        // reflect in hash (optional)
        try { history.replaceState(null, '', `#tour/${step}`); } catch {}
      }
      function showTour(){ 
        overlay.classList.remove('hidden'); 
        overlay.setAttribute('aria-hidden','false'); 
        document.body.classList.add('tour-active');
        document.documentElement.classList.add('tour-active');
      }
      function hideTour(){ 
        overlay.classList.add('hidden'); 
        overlay.setAttribute('aria-hidden','true'); 
        document.body.classList.remove('tour-active');
        document.documentElement.classList.remove('tour-active');
        try { const btn = document.getElementById('tour-restart-btn'); if (btn) btn.style.display = 'inline-flex'; } catch {} 
      }
      function finishTour(){ 
        hideTour(); 
        try { localStorage.setItem('tour_done','1'); } catch {} 
        try { history.replaceState(null,'', location.pathname + location.search); } catch {}
        // Open "Основы UX для AI" section in HUD
        try {
          if (window.hud && typeof window.hud.openBasicsSection === 'function') {
            // Small delay to ensure HUD is ready
            setTimeout(() => {
              window.hud.openBasicsSection();
            }, 100);
          }
        } catch (e) {
          console.warn('[Tour] Failed to open basics section:', e);
        }
      }
      function dismissTour(){ 
        hideTour(); 
        // Mark tour as completed when closed from any step
        try { localStorage.setItem('tour_done','1'); } catch {} 
        try { history.replaceState(null,'', location.pathname + location.search); } catch {}
        // Open "Основы UX для AI" section in HUD
        try {
          if (window.hud && typeof window.hud.openBasicsSection === 'function') {
            // Small delay to ensure HUD is ready
            setTimeout(() => {
              window.hud.openBasicsSection();
            }, 100);
          }
        } catch (e) {
          console.warn('[Tour] Failed to open basics section:', e);
        }
      }

      // Expose hooks
      try { window.canShowTourRestartIcon = function(){ try { return localStorage.getItem('tour_done')==='1' && (document.getElementById('tour-overlay')?.classList.contains('hidden')||false); } catch { return false; } }; } catch {}
      try { window.setTourStep = setStep; } catch {}
      try { window.tour_reset = function(){ 
        try { 
          localStorage.removeItem('tour_done'); 
          localStorage.setItem('tour_step','1'); 
        } catch {} 
        setStep(1); 
        showTour(); 
      }; } catch {}

      // Block interactions under overlay handled by backdrop covering entire page via CSS

      // Schedule display as soon as preloader hides
      const tryShow = () => {
        const preHidden = !document.getElementById('preloader-overlay') || document.getElementById('preloader-overlay').classList.contains('hidden');
        if (!preHidden) { setTimeout(tryShow, 120); return; }
        const step = Number((typeof localStorage!=='undefined' && localStorage.getItem('tour_step')) || '1') || 1;
        setStep(step);
        console.log('analytics: tour_start');
        showTour();
      };
      // Close (X)
      try { const closeBtn = document.getElementById('tour-close'); if (closeBtn) { closeBtn.addEventListener('click', dismissTour); closeBtn.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' ') { e.preventDefault(); dismissTour(); } }); } } catch {}
      tryShow();
    })();

    // Ensure any prior custom cursor element is removed
    try { const old = document.getElementById('custom-cursor'); if (old) old.remove(); } catch(_) {}

    // -------- HUD Grid (through-borders) ----------
    // Renders 1px lines across the whole viewport at the edges of HUD panels.
    const GRID_COLOR = 'rgba(120, 220, 255, 0.25)';
    const overlay = document.getElementById('grid-overlay');
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.pointerEvents = 'none';
    overlay.style.zIndex = '850'; // above scene, below labels/HUD
    // Disable DOM-line overlay; we will draw via canvas for reliable animation
    overlay.style.display = 'none';

    // Canvas grid overlay (reliable, animated in sync with core pulse)
    const canvas = document.getElementById('grid-canvas');
    const canvasBg = document.getElementById('grid-canvas-bg');
    canvas.style.position = 'fixed';
    canvas.style.inset = '0';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = '850';
    if (canvasBg) {
      canvasBg.style.position = 'fixed';
      canvasBg.style.inset = '0';
      canvasBg.style.pointerEvents = 'none';
      canvasBg.style.zIndex = '890';
    }
    // Grid only active in HUD mode or during tour
    function isGridActive() {
      const root = document.documentElement;
      const tourOverlay = document.getElementById('tour-overlay');
      const tourActive = tourOverlay && !tourOverlay.classList.contains('hidden');
      return root.classList.contains('hud-active') || root.classList.contains('links-active') || tourActive;
    }
    var GRID_SIMPLE = false; // bind to Calm wireframe
    let ctx = canvas.getContext('2d');
    let ctxBg = canvasBg ? canvasBg.getContext('2d') : null;
    // Flicker state synced to Calm intensity
    var _flicker = {
      lastI: 0,
      peaks: [], // {t0, dur, amp}
      activeUntil: 0,
      seed: Math.random()*1000
    };

    const LINE_THICK = 1; // px
    const targetsSelectors = [
      '#site-header',
      '#links-panel',
      '#hud-container',
      '#hud-small-panel',
      '#hud-big-panel',
      '#mobile-orbit-toggle'
    ];

    function clearLines() {
      while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
    }

    function addLine(x, y, w, h) {
      const dpr = window.devicePixelRatio || 1;
      const el = document.createElement('div');
      el.style.position = 'absolute';
      el.style.left = Math.floor(x) + 'px';
      el.style.top = Math.floor(y) + 'px';
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      el.className = 'grid-line ' + (h === 1 ? 'h' : 'v');
      // randomize dash/gap/phase so lines are desynchronized
      const rand = (min, max) => Math.random() * (max - min) + min;
      const dash = Math.round(rand(6, 14));
      const gap = Math.round(rand(6, 12));
      const phase = Math.round(rand(0, dash + gap));
      el.style.setProperty('--dash', dash + 'px');
      el.style.setProperty('--gap', gap + 'px');
      el.style.setProperty('--phase', phase + 'px');
      // crisp lines on fractional edges and high-DPI
      const fx = x - Math.floor(x);
      const fy = y - Math.floor(y);
      let tx = 0, ty = 0;
      if (Math.abs(fx - 0.5) < 0.26) tx = 0.5; // snap ~*.5px
      if (Math.abs(fy - 0.5) < 0.26) ty = 0.5;
      // On odd DPR physically shift lines by half pixel to sit on device pixel grid
      if (dpr % 2 !== 0) {
        if (w === 1) tx = tx || 0.5;
        if (h === 1) ty = ty || 0.5;
      }
      if (tx || ty) el.style.transform = `translate(${tx}px, ${ty}px)`;
      overlay.appendChild(el);
    }

    // Cache arrays for canvas drawing (declared early so buildGrid can fill them)
    let cachedXs = [], cachedYs = [], lineSeeds = new Map();
    let lineDirsX = [], lineDirsY = [];
    let prevFlashActive = false;
    // (grid cursor crosshair disabled)

    function buildGrid() {
      if (!isGridActive()) return;
      clearLines();
      const rects = [];
      // During tour, build grid for entire viewport (visible through overlays)
      const tourOverlay = document.getElementById('tour-overlay');
      const tourActive = tourOverlay && !tourOverlay.classList.contains('hidden');
      if (tourActive) {
        // For tour, create a full-screen grid with 24px spacing (like HUD mode)
        // This will be visible through the transparent card
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const GRID_STEP = 24;
        // Generate grid lines across entire viewport
        const gridXs = new Set();
        const gridYs = new Set();
        for (let x = 0; x <= vw; x += GRID_STEP) {
          gridXs.add(x);
        }
        for (let y = 0; y <= vh; y += GRID_STEP) {
          gridYs.add(y);
        }
        // Store for drawing (will be used in drawCanvasGrid)
        cachedXs = Array.from(gridXs).sort((a,b)=>a-b);
        cachedYs = Array.from(gridYs).sort((a,b)=>a-b);
        // Assign random seeds for flicker
        lineSeeds = new Map();
        cachedXs.forEach((x,i)=> lineSeeds.set('x'+i, Math.random()));
        cachedYs.forEach((y,i)=> lineSeeds.set('y'+i, Math.random()));
        return; // Skip normal grid building for tour
      } else {
        // Normal HUD mode: build grid around specific elements
        targetsSelectors.forEach(sel => {
          const el = document.querySelector(sel);
          if (!el) return;
          const r = el.getBoundingClientRect();
          if (r.width > 0 && r.height > 0) rects.push(r);
          // также учесть прямых детей (строки/карточки внутри малого HUD)
          if (el.id === 'hud-small-panel') {
            el.childNodes.forEach(n => {
              if (n.nodeType !== 1) return;
              const rr = n.getBoundingClientRect();
              if (rr.width > 0 && rr.height > 0) rects.push(rr);
            });
          }
        });
      }
      if (rects.length === 0) return;

      // Собираем уникальные X/Y краёв
      const xs = new Set();
      const ys = new Set();
      rects.forEach(r => {
        const left = r.left;
        const right = r.right - LINE_THICK;   // align to the visible right border
        const top = r.top;
        const bottom = r.bottom - LINE_THICK; // align to the visible bottom border
        xs.add(left);
        xs.add(right);
        ys.add(top);
        ys.add(bottom);
      });

      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // Compute canvas size with device pixel ratio for crisp 1px strokes
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(vw * dpr);
      canvas.height = Math.floor(vh * dpr);
      canvas.style.width = vw + 'px';
      canvas.style.height = vh + 'px';
      ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Cache edges for canvas drawing
      // Exclude the area next to the scrollbar (avoid rightmost vertical line)
      const rightGutter = 18; // ~scrollbar width on Win
      cachedXs = Array.from(xs).sort((a,b)=>a-b).filter(x => x > 0.5 && x < (vw - rightGutter));
      cachedYs = Array.from(ys).sort((a,b)=>a-b).filter(y => y > 0.5 && y < vh - 0.5);
      // assign random dash settings per line for desync
      lineSeeds = new Map();
      cachedXs.forEach((x,i)=> lineSeeds.set('x'+i, Math.random()));
      cachedYs.forEach((y,i)=> lineSeeds.set('y'+i, Math.random()));
      // initialize directions (+1/-1) per line
      lineDirsX = cachedXs.map(()=> (Math.random()<0.5? -1: 1));
      lineDirsY = cachedYs.map(()=> (Math.random()<0.5? -1: 1));
      drawCanvasGrid(0);
    }

    // Рисуем после монтирования темы (несколько тактов, чтобы схватить поздние размеры)
    function scheduleBuildBurst() {
      buildGrid();
      requestAnimationFrame(buildGrid);
      setTimeout(buildGrid, 50);
      setTimeout(buildGrid, 150);
    }
    // Mobile HUD: keep 20px gap below site header
    function updateMobileHudTop(){
      try {
        const isMobile = window.innerWidth <= 479;
        const header = document.getElementById('site-header');
        const hudContainer = document.getElementById('hud-container');
        if (!header || !hudContainer) return;
        if (isMobile) {
          const h = Math.round(header.getBoundingClientRect().height || 0);
          hudContainer.style.setProperty('top', (h + 20) + 'px', 'important');
        } else {
          // restore desktop top from CSS
          hudContainer.style.removeProperty('top');
        }
      } catch {}
    }
    engine.on('themeMounted', () => {
      scheduleBuildBurst();
      updateMobileHudTop();
    });
    // Debounced resize handler for mobile HUD positioning
    let resizeHudTimeout = null;
    const debouncedUpdateMobileHudTop = () => {
      clearTimeout(resizeHudTimeout);
      resizeHudTimeout = setTimeout(() => {
        updateMobileHudTop();
      }, 150);
    };
    try { window.addEventListener('resize', debouncedUpdateMobileHudTop, { passive: true }); } catch {}

    // Initial draw at startup (before any theme mounts) so Calm/Matrix both show lines
    scheduleBuildBurst();

    // --- Canvas drawing loop ---
    // Listen for Calm scene pulse events
    var pulseHueDeg = 200; var pulseUntilMs = 0; var forceStepUntilMs = 0;
    var pulseIntensity = null; // 0..1 from Calm
    // Synthetic flicker (working baseline): fast sine + noisy threshold, no scheduler
    var flashLevel = 0.12; // current alpha
    var lastMs = (typeof performance !== 'undefined') ? performance.now() : Date.now();
    var noiseSeed = Math.random()*1000;
    try {
      window.addEventListener('calmPulse', (e) => {
        const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
        const detail = (e && e.detail) || {};
        const hueDeg = (typeof detail.hueDeg === 'number') ? detail.hueDeg : 200;
        const inten = (typeof detail.intensity === 'number') ? Math.max(0, Math.min(1, detail.intensity)) : null;
        pulseHueDeg = hueDeg;
        pulseIntensity = inten;
        pulseUntilMs = now + 320; // longer 320ms flash for visibility
        forceStepUntilMs = pulseUntilMs;
      });
    } catch(_) {}
    function pulseColor(t){
      // Prefer Calm wireframe state if available
      let sceneHue = null; let sceneFlash = null; let sceneRgb = null; let sceneIntensity = null; let hasWF = false;
      let syntheticFlashActive = null;
      try {
        // Highest priority: direct Calm getter if present
        let wf = null;
        if (typeof window.__getCalmWireframeState === 'function') {
          wf = window.__getCalmWireframeState();
        } else if (window._calmPlugin && typeof window._calmPlugin.getWireframeState === 'function') {
          wf = window._calmPlugin.getWireframeState();
        } else if (window._engine && window._engine.currentPlugin && typeof window._engine.currentPlugin.getWireframeState === 'function') {
          wf = window._engine.currentPlugin.getWireframeState();
        }
        if (wf) {
          hasWF = true;
          if (typeof wf.hueDeg === 'number') sceneHue = wf.hueDeg;
          if (typeof wf.flash === 'number') sceneFlash = wf.flash;
          if (wf.rgb && typeof wf.rgb.r === 'number') sceneRgb = wf.rgb;
          if (typeof wf.intensity === 'number') sceneIntensity = Math.max(0, Math.min(1, wf.intensity));
        }
        // Fallback to Calm globals if plugin state is unavailable
        if (!hasWF && typeof window !== 'undefined') {
          if (typeof window._coreHueDeg === 'number') sceneHue = window._coreHueDeg;
          if (typeof window._corePulse === 'number') sceneIntensity = Math.max(0, Math.min(1, window._corePulse));
          if (typeof window._corePulseStep === 'number') sceneFlash = window._corePulseStep;
        }
        // Always read from Three.js scene by object name (authoritative if present)
        {
          const eng = window._engine;
          const obj = eng && eng.scene && typeof eng.scene.getObjectByName === 'function'
            ? eng.scene.getObjectByName('CalmCoreWire')
            : null;
          if (obj && obj.material) {
            const m = obj.material;
            if (typeof m.opacity === 'number') sceneIntensity = Math.max(0, Math.min(1, m.opacity));
            if (m.color) {
              const c = m.color;
              const max = Math.max(c.r, c.g, c.b), min = Math.min(c.r, c.g, c.b);
              let h = 200; const d = max - min;
              if (d > 1e-5) {
                if (max === c.r) h = ((c.g - c.b) / d) % 6;
                else if (max === c.g) h = (c.b - c.r) / d + 2;
                else h = (c.r - c.g) / d + 4;
                h *= 60; if (h < 0) h += 360;
              }
              sceneHue = h;
              sceneRgb = { r: Math.round(c.r*255), g: Math.round(c.g*255), b: Math.round(c.b*255) };
            }
          }
        }
      } catch(_) {}

      // If Calm is not providing state, synthesize it using the same style as Calm core
      const synthNeeded = !hasWF;
      if (synthNeeded) {
        // Synthetic color base (Calm core blue range)
        const tsec = t;
        const phase = 0.5 + 0.5*Math.sin(tsec * 0.60 * 2.0); // warpSpeed ~0.60
        const cO = { r: 0x58/255, g: 0xb7/255, b: 0xff/255 };
        const cI = { r: 0xa5/255, g: 0xf0/255, b: 0xff/255 };
        let baseR = (cO.r + (cI.r - cO.r) * phase) * 255;
        let baseG = (cO.g + (cI.g - cO.g) * phase) * 255;
        let baseB = (cO.b + (cI.b - cO.b) * phase) * 255;

        const nowMs = (typeof performance !== 'undefined') ? performance.now() : Date.now();
        const dt = Math.max(0, (nowMs - lastMs) / 1000);
        lastMs = nowMs;
        // Non-uniform threshold with noise; irregular but no scheduler
        const n = Math.sin(tsec*0.73 + noiseSeed) * 0.08; // slow noise
        const fast = Math.sin(tsec * 6.0 + Math.sin(tsec*1.5+noiseSeed)*0.33);
        const thr = 0.78 + n; // 0.70..0.86 jitter
        const isFlash = fast > thr;
        // Warm flash palette (yellow/orange/red blend)
        const warmMix = 0.5 + 0.5*Math.sin(tsec*3.1 + noiseSeed);
        const warmR = (0xff*(1-warmMix) + 0xff*warmMix);
        const warmG = (0xd2*(1-warmMix) + 0x4d*warmMix);
        const warmB = (0x4d*(1-warmMix) + 0x4d*warmMix);
        sceneRgb = isFlash
          ? { r: Math.round(warmR), g: Math.round(warmG), b: Math.round(warmB) }
          : { r: Math.round(baseR), g: Math.round(baseG), b: Math.round(baseB) };
        // Sharp rise/decay to targets
        const target = isFlash ? 0.28 : 0.10;
        const k = isFlash ? 22.0 : 12.0;
        flashLevel += (target - flashLevel) * (1 - Math.exp(-k*dt));
        const micro = Math.sin(tsec*37 + noiseSeed*2.3) * 0.012;
        sceneFlash = flashLevel + micro;
        syntheticFlashActive = isFlash;
        // Do not return here; continue to compute stroke below
      }

      // Visibility: if calmPulse window is active and carries intensity, use it strictly
      const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
      if (now < (pulseUntilMs||0) && typeof pulseIntensity === 'number') {
        // Step-like flash: no tails, slightly higher base
        const a = 0.16 + 0.22 * Math.max(0, Math.min(1, pulseIntensity));
        const hue = pulseHueDeg || 200;
        // Convert hue to RGB
        const H = ((hue % 360) + 360) % 360, S = 0.90, L = 0.70;
        const C = (1-Math.abs(2*L-1))*S; const X = C*(1-Math.abs(((H/60)%2)-1)); const m=L-C/2;
        let r1=0,g1=0,b1=0; const hSeg=Math.floor(H/60);
        if (hSeg===0){r1=C;g1=X;b1=0;} else if (hSeg===1){r1=X;g1=C;b1=0;} else if (hSeg===2){r1=0;g1=C;b1=X;} else if (hSeg===3){r1=0;g1=X;b1=C;} else if (hSeg===4){r1=X;g1=0;b1=C;} else {r1=C;g1=0;b1=X;}
        const rr = Math.round((r1+m)*255), gg = Math.round((g1+m)*255), bb = Math.round((b1+m)*255);
        return { stroke: `rgba(${rr},${gg},${bb},${a.toFixed(3)})`, p: 0, flashActive: true, alpha: a, hue: hue, intensity: pulseIntensity };
      }

      // Visibility: if we have sceneFlash as numeric alpha, use it; else step-only baseline
      let step = (typeof window !== 'undefined' && typeof window._corePulseStep === 'number') ? window._corePulseStep : null;
      let alpha;
      if (typeof sceneIntensity === 'number') {
        // Baseline strictly tied to Calm intensity (no randoms) — slightly higher base
        alpha = 0.22 + 0.16 * sceneIntensity;
      } else {
        if (sceneFlash != null) step = sceneFlash;
        alpha = (step === 0 || step === 1) ? (step === 1 ? 0.65 : 0.24) : 0.24;
      }

      // Stroke color
      const computedFlashActive = (syntheticFlashActive !== null) ? syntheticFlashActive : (!!step);
      if (sceneRgb) {
        const { r, g, b } = sceneRgb;
        return { stroke: `rgba(${r},${g},${b},${alpha.toFixed(3)})`, p: 0, flashActive: computedFlashActive, alpha, hue: sceneHue, intensity: sceneIntensity };
      }

      // Fallback to hue
      const baseHue = (sceneHue != null) ? sceneHue : 200;
      const H = ((baseHue % 360) + 360) % 360, S = 0.90, L = 0.70;
      const C = (1-Math.abs(2*L-1))*S; const X = C*(1-Math.abs(((H/60)%2)-1)); const m=L-C/2;
      let r1=0,g1=0,b1=0; const hSeg=Math.floor(H/60);
      if (hSeg===0){r1=C;g1=X;b1=0;} else if (hSeg===1){r1=X;g1=C;b1=0;} else if (hSeg===2){r1=0;g1=C;b1=X;} else if (hSeg===3){r1=0;g1=X;b1=C;} else if (hSeg===4){r1=X;g1=0;b1=C;} else {r1=C;g1=0;b1=X;}
      const rr = Math.round((r1+m)*255), gg = Math.round((g1+m)*255), bb = Math.round((b1+m)*255);
      return { stroke: `rgba(${rr},${gg},${bb},${alpha.toFixed(3)})`, p: 0, flashActive: computedFlashActive, alpha, hue: baseHue, intensity: sceneIntensity };
    }
    function drawCanvasGrid(t){
      try {
        if (!ctx) return;
        const vw = window.innerWidth, vh = window.innerHeight;
        // Ensure canvas matches viewport even when HUD is inactive (for crosshair)
        const dpr = window.devicePixelRatio || 1;
        const needResize = canvas.width !== Math.floor(vw * dpr) || canvas.height !== Math.floor(vh * dpr);
        if (needResize) {
          canvas.width = Math.floor(vw * dpr);
          canvas.height = Math.floor(vh * dpr);
          canvas.style.width = vw + 'px';
          canvas.style.height = vh + 'px';
          ctx = canvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        // Sync background canvas size
        if (canvasBg && ctxBg) {
          const needResizeBg = canvasBg.width !== Math.floor(vw * dpr) || canvasBg.height !== Math.floor(vh * dpr);
          if (needResizeBg) {
            canvasBg.width = Math.floor(vw * dpr);
            canvasBg.height = Math.floor(vh * dpr);
            canvasBg.style.width = vw + 'px';
            canvasBg.style.height = vh + 'px';
            ctxBg = canvasBg.getContext('2d');
            ctxBg.setTransform(dpr, 0, 0, dpr, 0, 0);
          }
        }
        ctx.clearRect(0,0,vw,vh);
        const pc = pulseColor(t/1000);
        const nowFlash = !!pc.flashActive;
        prevFlashActive = nowFlash;
        const hudOrLinks = isGridActive();
        const linksActive = document.documentElement.classList.contains('links-active');
        const hudActiveFlag = document.documentElement.classList.contains('hud-active');
        const tourOverlayEl = document.getElementById('tour-overlay');
        const tourActive = tourOverlayEl && !tourOverlayEl.classList.contains('hidden');
        const hudOnly = hudActiveFlag && !linksActive && !tourActive;
        // Base border color #243041 with reduced opacity
        const baseBorderColor = 'rgba(36,48,65,0.35)'; // reduced visibility
        // In HUD mode reduce flash visibility from 0.27 to 0.18
        const flashColor = hudOnly ? 'rgba(91,156,255,0.18)' : 'rgba(91,156,255,0.27)';
        ctx.lineWidth = 1;
        if (hudOrLinks) {
          // Draw grid lines only in HUD/Links mode
          // Solid lines (no dash) with very subtle color flicker during flash (all lines)
          cachedXs.forEach((x,i)=>{
            const seed = lineSeeds.get('x'+i) || 0.5;
            let lineColor = baseBorderColor;
            if (nowFlash) {
              // Very subtle flicker - very slow and barely noticeable
              const freq = 12; // much slower frequency
              const duty = 0.15; // shorter flash duration
              const ph = (t*freq + seed*3) % 1;
              const strobeOn = ph < duty;
              lineColor = strobeOn ? flashColor : baseBorderColor;
            }
            ctx.strokeStyle = lineColor;
            ctx.setLineDash([]); // solid line
            ctx.beginPath();
            // half-pixel align for crispness
            ctx.moveTo(Math.round(x)+0.5, 0);
            ctx.lineTo(Math.round(x)+0.5, vh);
            ctx.stroke();
          });
          cachedYs.forEach((y,i)=>{
            const seed = lineSeeds.get('y'+i) || 0.5;
            let lineColor = baseBorderColor;
            if (nowFlash) {
              // Very subtle flicker - very slow and barely noticeable
              const freq = 12; // much slower frequency
              const duty = 0.15; // shorter flash duration
              const ph = (t*freq + seed*3.7) % 1; // slightly different seed
              const strobeOn = ph < duty;
              lineColor = strobeOn ? flashColor : baseBorderColor;
            }
            ctx.strokeStyle = lineColor;
            ctx.setLineDash([]); // solid line
            ctx.beginPath();
            ctx.moveTo(0, Math.round(y)+0.5);
            ctx.lineTo(vw, Math.round(y)+0.5);
            ctx.stroke();
          });
        }
        // Background grid under HUD overlay: full-screen grid like tour
        if (canvasBg && ctxBg) {
          ctxBg.clearRect(0,0,vw,vh);
          const isMobile = window.innerWidth <= 767;
          if (hudOnly || linksActive || tourActive || (isMobile && (hudActiveFlag || linksActive))) {
            // Base opacity same; flash depends on mode (tour brighter)
            const baseBorderColor = 'rgba(36,48,65,0.35)';
            const flashColor = tourActive ? 'rgba(91,156,255,0.27)' : 'rgba(91,156,255,0.18)';
            const step = 24;
            // subtle flicker synced with tour logic
            const freq = 12;
            const duty = 0.15;
            const doFlicker = nowFlash;
            // Vertical lines
            let i = 0;
            for (let x=0; x<=vw; x+=step, i++) {
              let color = baseBorderColor;
              if (doFlicker) {
                const seed = (i*0.173)%1; // deterministic seed per line
                const ph = (t*freq + seed*3) % 1;
                const strobeOn = ph < duty;
                color = strobeOn ? flashColor : baseBorderColor;
              }
              ctxBg.strokeStyle = color;
              ctxBg.setLineDash([]);
              ctxBg.beginPath();
              ctxBg.moveTo(Math.round(x)+0.5, 0);
              ctxBg.lineTo(Math.round(x)+0.5, vh);
              ctxBg.stroke();
            }
            // Horizontal lines
            i = 0;
            for (let y=0; y<=vh; y+=step, i++) {
              let color = baseBorderColor;
              if (doFlicker) {
                const seed = (i*0.237)%1;
                const ph = (t*freq + seed*3.7) % 1;
                const strobeOn = ph < duty;
                color = strobeOn ? flashColor : baseBorderColor;
              }
              ctxBg.strokeStyle = color;
              ctxBg.setLineDash([]);
              ctxBg.beginPath();
              ctxBg.moveTo(0, Math.round(y)+0.5);
              ctxBg.lineTo(vw, Math.round(y)+0.5);
              ctxBg.stroke();
            }
          }
        }

        // (tour grid canvas removed)
        // --- Cursor crosshair (subtle) ---
        // Fade crosshair when idle
        // (grid cursor crosshair removed)
        // Debug HUD removed per request
      } catch (_) { /* swallow to keep app alive */ }
      requestAnimationFrame(drawCanvasGrid);
    }

    // Start the draw loop on startup (even outside HUD)
    try { requestAnimationFrame(drawCanvasGrid); } catch(_) {}

    // Перестраиваем на resize
    let gridTimer;
    window.addEventListener('resize', () => {
      clearTimeout(gridTimer);
      gridTimer = setTimeout(buildGrid, 100);
    });

    // Отслеживаем изменения layout HUD (display/классы/inline-стили)
    const moTargets = ['#site-header', '#links-panel', '#hud-container', '#hud-small-panel', '#hud-big-panel', '#mobile-orbit-toggle']
      .map(sel => document.querySelector(sel)).filter(Boolean);
    if (moTargets.length) {
      const mo = new MutationObserver(() => buildGrid());
      moTargets.forEach(t => mo.observe(t, { attributes: true, attributeFilter: ['style', 'class'], subtree: true }));
    }
    // Watch for hud-active class changes on document root and tour overlay
    const hudObserver = new MutationObserver(() => {
      if (isGridActive()) {
        buildGrid();
      } else {
        // Clear grid when HUD is inactive
        if (ctx) {
          const vw = window.innerWidth, vh = window.innerHeight;
          ctx.clearRect(0, 0, vw, vh);
        }
      }
    });
    // Also watch tour overlay for show/hide
    const tourOverlay = document.getElementById('tour-overlay');
    if (tourOverlay) {
      const tourObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            const isHidden = tourOverlay.classList.contains('hidden');
            if (isHidden) {
              document.body.classList.remove('tour-active');
            } else {
              document.body.classList.add('tour-active');
              buildGrid(); // rebuild grid when tour opens
            }
            // Trigger grid rebuild
            if (isGridActive()) {
              buildGrid();
            } else {
              if (ctx) {
                const vw = window.innerWidth, vh = window.innerHeight;
                ctx.clearRect(0, 0, vw, vh);
              }
            }
          }
        });
      });
      tourObserver.observe(tourOverlay, { attributes: true, attributeFilter: ['class'] });
    }
    hudObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
    
    // Resize handler
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        engine.resize(window.innerWidth, window.innerHeight);
      }, 250);
    });
    
    engine.resize(window.innerWidth, window.innerHeight);
    
  } catch (error) {
    console.error('[Bootstrap] ❌ Error:', error);
    // Do not replace body; keep app visible for diagnostics
  }
}

init();
</script>
</body>
</html>

